"
Builtin contexts are contexts that cannot be defined in Leibniz itself, because they make use of builtin terms such as numbers or strings. {{gtMethod:name=LzBuiltinContexts class>>#truthContext}} is an exception: it could very well be defined as a standard Leibniz context, but since it is used by the number contexts, it is part of the builtin contexts as well.

"
Class {
	#name : #LzBuiltinContexts,
	#superclass : #Object,
	#classVars : [
		'ArrayContext',
		'EqualityContext',
		'IntegerContext',
		'RationalNumberContext',
		'RealNumberContext',
		'StringContext',
		'TruthContext'
	],
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #defining }
LzBuiltinContexts class >> arrayAppendContext [
	^ LzContextBuilder new
		include: self arrayContext;
		op: 's_:ùïä, ',
				'(Array1D(s_)) ‚ßü (Array1D(s_)) : Array1D(s_)';
		op: 's_:ùïä, n_:‚Ñï, m_:‚Ñï, ',
				'(Array(s_, n_)) ‚ßü (Array(s_, m_)) : Array(s_, n_ + m_)';
		op: 's_:ùïä, ',
				'(Array1D(s_)) ‚ßü (EmptyArray1D) : Array1D(s_)';
		rule: 's__:ùïä, ',
				'A_:Array1D(s__), B_:Array1D(s__), ',
				'A_ ‚ßü B_ ‚Üí ''A ensureArrayTerm. B ensureArrayTerm. A append: B'':nil';
		op: 's_:ùïä, ',
				'(EmptyArray1D) ‚ßü (Array1D(s_)) : Array1D(s_)';
		rule: 's__:ùïä, ',
				'e_:EmptyArray1D, a_:Array1D(s__), ',
				'e_ ‚ßü a_ ‚áí a_';
		rule: 's__:ùïä, ',
				'e_:EmptyArray1D, a_:Array1D(s__), ',
				'a_ ‚ßü e_ ‚áí a_';
		op: 's_:ùïä, ',
				'(EmptyArray1D) ‚ßü (EmptyArray1D) : EmptyArray1D';
		rule: 's__:ùïä, ',
				'e1_:EmptyArray1D, e2_:EmptyArray1D, ',
				'e1_ ‚ßü e2_ ‚áí e1_';

		op: 's_:ùïä, ',
				'(Array1D(s_)) ‚üú (s_) : Array1D(s_)';
		op: 's_:ùïä, n_:‚Ñï, ',
				'(Array(s_, n_)) ‚üú (s_) : Array(s_, succ(n_))';
		rule: 's__:ùïä, ',
				'a_:Array1D(s__), v_:s__, ',
				'a_ ‚üú v_ ‚áí a_ ‚ßü {[ v_ ]}';
		op: 's_:ùïä, ',
				'(EmptyArray1D) ‚üú (s_) : Array(s_, 1)';
		rule: 's__:ùïä, ',
				'e_:EmptyArray1D, v_:s__, ',
				'e_ ‚üú v_ ‚áí {[ v_ ]}';

		op: 's_:ùïä, ',
				'(s_) ‚ä∏ (Array1D(s_)) : Array1D(s_)';
		op: 's_:ùïä, n_:‚Ñï, ',
				'(s_) ‚ä∏ (Array(s_, n_)) : Array(s_, succ(n_))';
		rule: 's__:ùïä, ',
				'a_:Array1D(s__), v_:s__, ',
				'v_ ‚ä∏ a_ ‚áí {[ v_ ]} ‚ßü a_';
		op: 's_:ùïä, ',
				'(s_) ‚ä∏ (EmptyArray1D) : Array(s_, 1)';
		rule: 's__:ùïä, ',
				'e_:EmptyArray1D, v_:s__, ',
				'v_ ‚ä∏ e_ ‚áí {[ v_ ]}';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayContext [
	ArrayContext ifNil: [
		| builder |
		builder := LzContextBuilder new
					includeSortContext: LzBuiltinContexts integerContext;
					include: LzBuiltinContexts integerContext;
					builtin: #arrays.
		self arraySortsFor: builder.
		self arrayOpsFor: builder.
		ArrayContext := builder context ].
	^ ArrayContext
]

{ #category : #defining }
LzBuiltinContexts class >> arrayFoldContext [
	^ LzContextBuilder new
		include: self arrayContext;
		include: self functionContext;
		op: '‚àÄ s_:ùïä ',
			'fold(fn(s_, s_, s_), s_, Array1D(s_)) : s_';
		rule: '‚àÄ s__:ùïä ',
				'‚àÄ F_:fn(s__, s__, s__) ',
				'‚àÄ V_:s__ ',
				'‚àÄ A_:Array1D(s__) ',
				'fold(F_, V_, A_) ‚Üí ''A ensureArrayTerm. A inject: V into: F reducer: reducer'':nil';
		op: '‚àÄ s_:ùïä ',
			'fold(fn(s_, s_, s_), s_, EmptyArray) : s_';
		rule: '‚àÄ s__:ùïä ‚àÄ f_:fn(s__, s__, s__) ',
				'‚àÄ v_:s__ ‚àÄ a_:EmptyArray ',
				'fold(f_, v_, a_) ‚áí v_';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayIndexingContext [
	^ LzContextBuilder new
		include: self arrayContext;
		sort: '‚ãØ';
		op: '‚Ñï.nz ‚ãØ ‚Ñï.nz : ‚ãØ';
		op: '‚àé : ‚Ñï.nz';
		op: '‚àÄ s_:ùïä ',
				'(Array1D(s_))[‚Ñï.nz] : s_';
		rule: '‚àÄ s__:ùïä ',
				'‚àÄ A_:Array1D(s__) ',
				'‚àÄ i_:‚Ñï.nz ',
				'A_[i_] ‚Üí ''A ensureArrayTerm. A index: i'':nil';
		op: '‚àÄ s_:ùïä ',
				'(Array1D(s_))[‚ãØ] : Array1D(s_)';
		rule: '‚àÄ s__:ùïä ',
				'‚àÄ A_:Array1D(s__) ',
				'‚àÄ i_:‚Ñï.nz ',
				'A_[i_ ‚ãØ ‚àé] ‚Üí ''A ensureArrayTerm. A sliceToEndFrom: i by: 1'':nil';
		rule: '‚àÄ s__:ùïä ',
				'‚àÄ A_:Array1D(s__) ',
				'‚àÄ i_:‚Ñï.nz ‚àÄ j_:‚Ñï.nz ',
				'A_[i_ ‚ãØ j_] ‚Üí ''A ensureArrayTerm. A slice: i to: j by: 1'':nil';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayMap2Context [
	^ LzContextBuilder new
		include: self arrayContext;
		include: self functionContext;
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, ',
			'(fn(from1_, from2_, to_))[Array(from1_), Array(from2_)] : Array(to_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_), Array(from2_, i_)] : Array(to_, i_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, j_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_, j_), Array(from2_, i_, j_)] : Array(to_, i_, j_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, j_:‚Ñï, k_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_, j_, k_), Array(from2_, i_, j_, k_)] : Array(to_, i_, j_, k_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, j_:‚Ñï, k_:‚Ñï, l_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_, j_, k_, l_), Array(from2_, i_, j_, k_, l_)] : Array(to_, i_, j_, k_, l_)';
		rule: 'from1__:ùïä, from2__:ùïä, to__:ùïä, ',
				'F_:fn(from1__,, from2__, to__) ',
				'A_:Array(from1__), ',
				'B_:Array(from2__), ',
				'F_[A_, B_] ‚Üí ''A ensureArrayTerm. B ensureArrayTerm. A with: B applyFn: F reducer: reducer'':nil';

		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, ',
			'(fn(from1_, from2_, to_))[EmptyArray, EmptyArray] : EmptyArray';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_), EmptyArray(i_)] : EmptyArray(i_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, j_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_, j_), EmptyArray(i_, j_)] : EmptyArray(i_, j_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, j_:‚Ñï, k_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_, j_, k_), EmptyArray(i_, j_, k_)] : EmptyArray(i_, j_, k_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, i_:‚Ñï, j_:‚Ñï, k_:‚Ñï, l_:‚Ñï, ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_, j_, k_, l_), EmptyArray(i_, j_, k_, l_)] : EmptyArray(i_, j_, k_, l_)';
		rule: 'from1__:ùïä, from2__:ùïä, to__:ùïä, ',
				'f_:fn(from1__,, from2__, to__) ',
				'a_:EmptyArray, ',
				'f_[a_, a_] ‚áí a_';
		context

]

{ #category : #defining }
LzBuiltinContexts class >> arrayMapContext [
	^ LzContextBuilder new
		include: self arrayContext;
		include: self functionContext;
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ',
			'(fn(from_, to_))[Array(from_)] : Array(to_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ',
			'(fn(from_, to_))[Array(from_, i_)] : Array(to_, i_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ‚àÄ j_:‚Ñï ',
			'(fn(from_, to_))[Array(from_, i_, j_)] : Array(to_, i_, j_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ‚àÄ j_:‚Ñï ‚àÄ k_:‚Ñï ',
			'(fn(from_, to_))[Array(from_, i_, j_, k_)] : Array(to_, i_, j_, k_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ‚àÄ j_:‚Ñï ‚àÄ k_:‚Ñï ‚àÄ l_:‚Ñï ',
			'(fn(from_, to_))[Array(from_, i_, j_, k_, l_)] : Array(to_, i_, j_, k_, l_)';
		rule: '‚àÄ from__:ùïä ‚àÄ to__:ùïä ‚àÄ F_:fn(from__, to__) ',
				'‚àÄ A_:Array(from__) ',
				'F_[A_] ‚Üí ''A ensureArrayTerm. A applyFn: F reducer: reducer'':nil';

		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ',
			'(fn(from_, to_))[EmptyArray] : EmptyArray';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ',
			'(fn(from_, to_))[EmptyArray(i_)] : EmptyArray(i_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ‚àÄ j_:‚Ñï ',
			'(fn(from_, to_))[EmptyArray(i_, j_)] : EmptyArray(i_, j_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ‚àÄ j_:‚Ñï ‚àÄ k_:‚Ñï ',
			'(fn(from_, to_))[EmptyArray(i_, j_, k_)] : EmptyArray(i_, j_, k_)';
		op: '‚àÄ from_:ùïä ‚àÄ to_:ùïä ‚àÄ i_:‚Ñï ‚àÄ j_:‚Ñï ‚àÄ k_:‚Ñï ‚àÄ l_:‚Ñï ',
			'(fn(from_, to_))[EmptyArray(i_, j_, k_, l_)] : EmptyArray(i_, j_, k_, l_)';
		rule: '‚àÄ from__:ùïä ‚àÄ to__:ùïä ‚àÄ f_:fn(from__, to__) ',
				'‚àÄ a_:EmptyArray ',
				'f_[a_] ‚áí a_';
		context
]

{ #category : #private }
LzBuiltinContexts class >> arrayOpsFor: builder [
	builder
		op: '‚àÄ s_:ùïä shape(Array(s_)) : Array(‚Ñï)';
		rule: '‚àÄ s__:ùïä ‚àÄ A_:Array(s__) shape(A_) ‚Üí ''A shapeAsArrayTerm'':nil'.
]

{ #category : #private }
LzBuiltinContexts class >> arraySortsFor: builder [
	builder
		sort: 'Array(ùïä)';
		sort: 'Array1D(ùïä)';
		subsort: '‚àÄ s_:ùïä ',
					'Array1D(s_) ‚äÜ Array(s_)';
		sort: 'Array2D(ùïä)';
		subsort: '‚àÄ s_:ùïä ',
					'Array2D(s_) ‚äÜ Array(s_)';
		sort: 'Array3D(ùïä)';
		subsort: '‚àÄ s_:ùïä ',
					'Array3D(s_) ‚äÜ Array(s_)';
		sort: 'Array4D(ùïä)';
		subsort: '‚àÄ s_:ùïä ',
					'Array4D(s_) ‚äÜ Array(s_)';
		sort: 'Array(ùïä, ‚Ñï)';
		subsort: '‚àÄ s_:ùïä ‚àÄ i1_:‚Ñï ',
					'Array(s_, i1_) ‚äÜ Array1D(s_)';
		sort: 'Array(ùïä, ‚Ñï, ‚Ñï)';
		subsort: '‚àÄ s_:ùïä ‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ',
					'Array(s_, i1_, i2_) ‚äÜ Array2D(s_)';
		sort: 'Array(ùïä, ‚Ñï, ‚Ñï, ‚Ñï)';
		subsort: '‚àÄ s_:ùïä ‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ‚àÄ i3_:‚Ñï ',
					'Array(s_, i1_, i2_, i3_) ‚äÜ Array3D(s_)';
		sort: 'Array(ùïä, ‚Ñï, ‚Ñï, ‚Ñï, ‚Ñï)';
		subsort: '‚àÄ s_:ùïä ‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ‚àÄ i3_:‚Ñï ‚àÄ i4_:‚Ñï ',
					'Array(s_, i1_, i2_, i3_, i4_) ‚äÜ Array3D(s_)';
		sort: 'EmptyArray';
		sort: 'EmptyArray1D';
		sort: 'EmptyArray2D';
		sort: 'EmptyArray3D';
		sort: 'EmptyArray4D';
		subsort: 'EmptyArray1D ‚äÜ EmptyArray';
		subsort: 'EmptyArray2D ‚äÜ EmptyArray';
		subsort: 'EmptyArray3D ‚äÜ EmptyArray';
		subsort: 'EmptyArray4D ‚äÜ EmptyArray';
		sort: 'EmptyArray(‚Ñï)';
		subsort: '‚àÄ i1_:‚Ñï ',
					'EmptyArray(i1_) ‚äÜ EmptyArray1D';
		sort: 'EmptyArray(‚Ñï, ‚Ñï)';
		subsort: '‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ',
					'EmptyArray(i1_, i2_) ‚äÜ EmptyArray2D';
		subsort: '‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ',
					'EmptyArray(i1_, i2_) ‚äÜ EmptyArray(i1_)';
		sort: 'EmptyArray(‚Ñï, ‚Ñï, ‚Ñï)';
		subsort: '‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ‚àÄ i3_:‚Ñï ',
					'EmptyArray(i1_, i2_, i3_) ‚äÜ EmptyArray3D';
		subsort: '‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ‚àÄ i3_:‚Ñï ',
					'EmptyArray(i1_, i2_, i3_) ‚äÜ EmptyArray(i1_, i2_)';
		sort: 'EmptyArray(‚Ñï, ‚Ñï, ‚Ñï, ‚Ñï)';
		subsort: '‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ‚àÄ i3_:‚Ñï ‚àÄ i4_:‚Ñï ',
					'EmptyArray(i1_, i2_, i3_, i4_) ‚äÜ EmptyArray4D';
		subsort: '‚àÄ i1_:‚Ñï ‚àÄ i2_:‚Ñï ‚àÄ i3_:‚Ñï ‚àÄ i4_:‚Ñï ',
					'EmptyArray(i1_, i2_, i3_, i4_) ‚äÜ EmptyArray(i1_, i2_, i3_)'
]

{ #category : #defining }
LzBuiltinContexts class >> equalityContext [
	^ LzBook contextNamed: 'Term equality'
]

{ #category : #defining }
LzBuiltinContexts class >> functionContext [
	^ LzContextBuilder new
		sort: 'from_:ùïä, to_:ùïä, ',
				'fn(from_, to_)';
		op: 'from_:ùïä, to_:ùïä, ',
				'(fn(from_, to_))[from_] : to_';
		sort: 'from1_:ùïä, from2_:ùïä, to_:ùïä, ',
				'fn(from1_, from2_, to_)';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, ',
				'(fn(from1_, from2_, to_))[from1_, from2_] : to_';
		op: 'from1_:ùïä, from2_:ùïä, to_:ùïä, ',
				'(fn(from1_, from2_, to_))[from1_] : fn(from2_, to_)';
		rule: 'from1__:ùïä, from2__:ùïä, to__:ùïä, ',
				'f_:fn(from1__,, from2__, to__) ',
				'a_:from1__, b_:from2__, ',
				'(f_[a_])[b_] ‚áí f_[a_, b_]';
		context
]

{ #category : #private }
LzBuiltinContexts class >> integerAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'x_:‚Ñ§, y_:‚Ñ§ , x_ + y_ = y_ + x_';
		axiom: 'x_:‚Ñ§, y_:‚Ñ§ , z_:‚Ñ§ , (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: 'x_:‚Ñ§, y_:‚Ñ§ , x_ √ó y_ = y_ √ó x_';
		axiom: 'x_:‚Ñ§, y_:‚Ñ§ , z_:‚Ñ§ , (x_ √ó y_) √ó z_ = x_ √ó (y_ √ó z_)';
		"distribution"
		axiom: 'x_:‚Ñ§, y_:‚Ñ§ , z_:‚Ñ§ , x_ √ó (y_ + z_) = (x_ √ó y_) + (x_ √ó z_)'
]

{ #category : #defining }
LzBuiltinContexts class >> integerContext [
	^ LzBook contextNamed: 'Integers'
]

{ #category : #private }
LzBuiltinContexts class >> integerOpsFor: aContextBuilder [
	aContextBuilder
		"Predecessor and successor for natural numbers"
		op: 'succ(‚Ñï) : ‚Ñï.nz';
		op: 'pred(‚Ñï.nz) : ‚Ñï';
		"Arithmetic operators"
		op: '‚Ñ§ + ‚Ñ§ : ‚Ñ§';
		op: '‚Ñï + ‚Ñï : ‚Ñï';
		op: '‚Ñï.nz + ‚Ñï.nz : ‚Ñï.nz';
		op: '‚Ñï.nz + ‚Ñï : ‚Ñï.nz';
		op: '‚Ñï + ‚Ñï.nz : ‚Ñï.nz';
		op: '‚Ñ§ - ‚Ñ§ : ‚Ñ§';
		op: '-(‚Ñ§) : ‚Ñ§';
		op: '‚Ñ§ √ó ‚Ñ§ : ‚Ñ§';
		op: '‚Ñï √ó ‚Ñï : ‚Ñï';
		op: '‚Ñï.nz √ó ‚Ñï.nz : ‚Ñï.nz';
		op: '‚Ñ§.nz √ó ‚Ñ§.nz : ‚Ñ§.nz';
		op: '‚Ñ§ div ‚Ñ§.nz : ‚Ñ§';
		op: '‚Ñï div ‚Ñï.nz : ‚Ñï';
		op: '‚Ñ§ rem ‚Ñ§.nz : ‚Ñ§';
		op: '‚Ñï rem ‚Ñï.nz : ‚Ñï';
		op: '‚Ñ§^(‚Ñï.nz) : ‚Ñ§';
		op: '‚Ñï^(‚Ñï.nz) : ‚Ñï';
		op: '‚Ñï.nz^(‚Ñï.nz) : ‚Ñï.nz';
		op: '‚Ñ§.nz^(‚Ñï.nz) : ‚Ñ§.nz';
		op: '‚Ñ§.nz^(zero) : ‚Ñï.nz';
		op: 'abs(‚Ñ§) : ‚Ñï';
		op: 'abs(‚Ñ§.nz) : ‚Ñï.nz';
		"Comparison operators"
		op: '‚Ñ§ < ‚Ñ§ : ùîπ';
		op: '‚Ñ§ > ‚Ñ§ : ùîπ';
		op: '‚Ñ§ ‚â§ ‚Ñ§ : ùîπ';
		op: '‚Ñ§ ‚â• ‚Ñ§ : ùîπ'.
]

{ #category : #private }
LzBuiltinContexts class >> integerRulesFor: aContextBuilder [
	aContextBuilder
		"predecessor/successor rules"
		rule: 'x_:‚Ñï.nz, pred(x_) ‚Üí ''x - 1'':LzIntegerTerm';
		rule: 'x_:‚Ñï, succ(x_) ‚Üí ''x + 1'':LzIntegerTerm';
		"addition rules"
		rule: 'x_:‚Ñ§, zero_:zero, x_ + zero_ ‚áí x_';
		rule: 'x_:‚Ñ§, zero_:zero, zero_ + x_ ‚áí x_';
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ + y_ ‚Üí ''x + y'':LzIntegerTerm';
		"subtraction rules"
		rule: 'x_:‚Ñ§, zero_:zero, x_ - zero_ ‚áí x_';
		rule: 'x_:‚Ñ§, zero_:zero, zero_ - x_ ‚áí -(x_)';
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ - y_ ‚Üí ''x - y'':LzIntegerTerm';
		rule: 'zero_:zero, -(zero_) ‚áí 0';
		rule: 'x_:‚Ñ§, -(x_) ‚Üí ''x negated'':LzIntegerTerm';
		"multiplication rules"
		rule: 'x_:‚Ñ§, zero_:zero, x_ √ó zero_ ‚áí 0';
		rule: 'x_:‚Ñ§, zero_:zero, zero_ √ó x_ ‚áí 0';
		rule: 'x_:‚Ñ§, 1 √ó x_ ‚áí x_';
		rule: 'x_:‚Ñ§, x_ √ó 1 ‚áí x_';
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ √ó y_ ‚Üí ''x * y'':LzIntegerTerm';
		"division rules"
		rule: 'x_:‚Ñ§.nz, zero_:zero, zero_ div x_ ‚áí 0';
		rule: 'x_:‚Ñ§, x_ div 1 ‚áí x_';
		rule: 'x_:‚Ñ§, y_:‚Ñ§.nz, x_ div y_ ‚Üí ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'x_:‚Ñ§.nz, zero_:zero, zero_ rem x_ ‚áí 0';
		rule: 'x_:‚Ñ§, x_ rem 1 ‚áí 0';
		rule: 'x_:‚Ñ§, y_:‚Ñ§.nz, x_ rem y_ ‚Üí ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"exponentiation rules"
		rule: 'x_:‚Ñ§.nz, zero_:zero, x_^(zero_) ‚áí 1';
		rule: 'x_:‚Ñï.nz, zero_:zero, zero_^(x_) ‚áí 0';
		rule: 'x_:‚Ñ§, y_:‚Ñï.nz, x_^(y_) ‚Üí ''x raisedTo: y'':LzIntegerTerm';
		"abs rules"
		rule: 'x_:‚Ñï, abs(x_) ‚áí x_';
		rule: 'x_:‚Ñ§, abs(x_) ‚áí -(x_) | x_ < 0';
		rule: 'x_:‚Ñ§, abs(x_) ‚Üí ''x abs'':LzIntegerTerm';
		"comparison rules"
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ < y_ ‚Üí ''x < y'':LzBooleanTerm';
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ > y_ ‚Üí ''x > y'':LzBooleanTerm';
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ ‚â§ y_ ‚Üí ''x <= y'':LzBooleanTerm';
		rule: 'x_:‚Ñ§, y_:‚Ñ§, x_ ‚â• y_ ‚Üí ''x >= y'':LzBooleanTerm'.
]

{ #category : #private }
LzBuiltinContexts class >> integerSortsFor: aContextBuilder [
	aContextBuilder
		"Natural numbers"
		sort: '‚Ñï';
		sort: '‚Ñï.nz';
		sort: 'zero';
		subsort: 'zero ‚äÜ ‚Ñï';
		subsort: '‚Ñï.nz ‚äÜ ‚Ñï';
		sort: 'one';
		subsort: 'one ‚äÜ ‚Ñï.nz';
		"Integers"
		sort: '‚Ñ§';
		sort: '‚Ñ§.nz';
		subsort: '‚Ñï ‚äÜ ‚Ñ§';
		subsort: '‚Ñ§.nz ‚äÜ ‚Ñ§';
		subsort: '‚Ñï.nz ‚äÜ ‚Ñ§.nz'.
]

{ #category : #private }
LzBuiltinContexts class >> numberArrayOpsAndRulesForBuilder: builder sort: s [
	builder
		op: '+ : fn(',s,', ',s,', ',s,')';
		rule: 'x_:',s,', y_:',s,', +[x_, y_] ‚áí x_ + y_';
		op: 'i_:‚Ñï.nz, (Array(',s,', i_)) + (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'i__:‚Ñï.nz, a_:Array(',s,',, i__) b_:Array(',s,',, i__) ',
				'a_ + b_ ‚áí +[a_, b_]';
		op: 'i_:zero, (EmptyArray(i_)) + (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'i__:‚Ñï, a_:EmptyArray(i__), b_:EmptyArray(i__), a_ + b_ ‚áí a_';

		op: 'Œ£(Array1D(',s,')) : ',s,'';
		op: 'i_:‚Ñï.nz, Œ£(Array(',s,', i_)) : ',s,'';
		rule: 'a_:Array1D(',s,')',
			'Œ£(a_) ‚áí fold(+, 0, a_)';

		op: '- : fn(',s,', ',s,', ',s,')';
		rule: 'x_:',s,', y_:',s,', -[x_, y_] ‚áí x_ - y_';
		op: 'i_:‚Ñï.nz, (Array(',s,', i_)) - (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'i__:‚Ñï.nz, a_:Array(',s,',, i__) b_:Array(',s,',, i__) ',
				'a_ - b_ ‚áí -[a_, b_]';
		op: 'i_:zero, (EmptyArray(i_)) - (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'i__:‚Ñï, a_:EmptyArray(i__), b_:EmptyArray(i__), a_ - b_ ‚áí a_';

		op: '√ó : fn(',s,', ',s,', ',s,')';
		rule: 'x_:',s,', y_:',s,', √ó[x_, y_] ‚áí x_ √ó y_';
		op: 'i_:‚Ñï.nz, (Array(',s,', i_)) √ó (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'i__:‚Ñï.nz, a_:Array(',s,',, i__) b_:Array(',s,',, i__) ',
				'a_ √ó b_ ‚áí √ó[a_, b_]';
		op: 'i_:zero, (EmptyArray(i_)) √ó (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'i__:‚Ñï, a_:EmptyArray(i__), b_:EmptyArray(i__), a_ √ó b_ ‚áí a_';

		op: 'Œ†(Array1D(',s,')) : ',s,'';
		op: 'i_:‚Ñï.nz, Œ†(Array(',s,', i_)) : ',s,'';
		rule: 'a_:Array1D(',s,')',
				'Œ†(a_) ‚áí fold(√ó, 1, a_)';

		op: '√∑ : fn(',s,', ',s,'.nz, ',s,')';
		rule: 'x_:',s,', y_:',s,'.nz, √∑[x_, y_] ‚áí x_ √∑ y_';
		op: 'i_:‚Ñï.nz, (Array(',s,', i_)) √∑ (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'i__:‚Ñï.nz, a_:Array(',s,',, i__) b_:Array(',s,',, i__) ',
				'a_ √∑ b_ ‚áí √∑[a_, b_]';
		op: 'i_:zero, (EmptyArray(i_)) √∑ (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'i__:‚Ñï, a_:EmptyArray(i__), b_:EmptyArray(i__), a_ √∑ b_ ‚áí a_'
]

{ #category : #defining }
LzBuiltinContexts class >> rationalNumberArrayContext [
	| builder |
	builder := LzContextBuilder new
		include: self arrayMap2Context;
		include: self arrayFoldContext;
		include: self rationalNumberContext.
	self numberArrayOpsAndRulesForBuilder: builder sort: '‚Ñö'.
	^ builder context
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö  x_ + y_ = y_ + x_';
		axiom: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö  ‚àÄ z_:‚Ñö  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö  x_ √ó y_ = y_ √ó x_';
		axiom: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö  ‚àÄ z_:‚Ñö  (x_ √ó y_) √ó z_ = x_ √ó (y_ √ó z_)';
		"distribution"
		axiom: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö  ‚àÄ z_:‚Ñö  x_ √ó (y_ + z_) = (x_ √ó y_) + (x_ √ó z_)'
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberBuiltinRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ + y_ ‚Üí ''x + y'':LzRationalNumberTerm';
		rule: '‚àÄ x_:‚Ñ§ ‚àÄ y_:‚Ñ§ x_ + y_ ‚Üí ''x + y'':LzIntegerTerm';
		"Subtraction rules"
		rule: '‚àÄ x_:‚Ñ§ ‚àÄ y_:‚Ñ§ x_ - y_ ‚Üí ''x - y'':LzIntegerTerm';
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ - y_ ‚Üí ''x - y'':LzRationalNumberTerm';
		"Negation rules"
		rule: '‚àÄ x_:‚Ñ§ -(x_) ‚Üí ''x negated'':LzIntegerTerm';
		rule: '‚àÄ x_:‚Ñö -(x_) ‚Üí ''x negated'':LzRationalNumberTerm';
		"Multiplication rules"
		rule: '‚àÄ x_:‚Ñ§ ‚àÄ y_:‚Ñ§ x_ √ó y_ ‚Üí ''x * y'':LzIntegerTerm';
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ √ó y_ ‚Üí ''x * y'':LzRationalNumberTerm';
		"Division rules"
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö.nz x_ √∑ y_ ‚Üí ''x / y'':LzRationalNumberTerm';
		"Integer div and rem rules"
		rule: '‚àÄ x_:‚Ñ§ ‚àÄ y_:‚Ñ§.nz x_ div y_ ‚Üí ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: '‚àÄ x_:‚Ñ§ ‚àÄ y_:‚Ñ§.nz x_ rem y_ ‚Üí ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"Exponentiation rules"
		rule: '‚àÄ x_:‚Ñ§ ‚àÄ y_:‚Ñï.nz x_^(y_) ‚Üí ''x raisedTo: y'':LzIntegerTerm';
		rule: '‚àÄ x_:‚Ñö.nz ‚àÄ y_:‚Ñ§.nz x_^(y_) ‚Üí ''x raisedTo: y'':LzRationalNumberTerm';
		"Abs rules"
		rule: '‚àÄ x_:‚Ñ§ abs(x_) ‚Üí ''x abs'':LzIntegerTerm';
		rule: '‚àÄ x_:‚Ñö abs(x_) ‚Üí ''x abs'':LzRationalNumberTerm'.
]

{ #category : #defining }
LzBuiltinContexts class >> rationalNumberContext [
	RationalNumberContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers;
			builtin: #rationalNumbers.
		self integerSortsFor: builder.
		self rationalNumberSortsFor: builder.
		self integerOpsFor: builder.
		self rationalNumberOpsFor: builder.
		"No integerAxioms, because they would be redundant."
		self rationalNumberAxiomsFor:  builder.
		"No integerRules, the few that are required are repeated in rationalRules."
		self rationalNumberRulesFor: builder.
		RationalNumberContext := builder context ].
	^ RationalNumberContext
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberOpsFor: aContextBuilder [
	aContextBuilder
		"Arithmetic operators"
		op: '‚Ñö + ‚Ñö : ‚Ñö';
		op: '‚Ñö.p + ‚Ñö.p : ‚Ñö.p';
		op: '‚Ñö.nn + ‚Ñö.nn : ‚Ñö.nn';
		op: '‚Ñö - ‚Ñö : ‚Ñö';
		op: '-(‚Ñö) : ‚Ñö';
		op: '‚Ñö √ó ‚Ñö : ‚Ñö';
		op: '‚Ñö.p √ó ‚Ñö.p : ‚Ñö.p';
		op: '‚Ñö.nn √ó ‚Ñö.nn : ‚Ñö.nn';
		op: '‚Ñö.nz √ó ‚Ñö.nz : ‚Ñö.nz';
		op: '‚Ñö √∑ ‚Ñö.nz : ‚Ñö';
		op: '‚Ñö.nz √∑ ‚Ñö.nz : ‚Ñö.nz';
		op: '‚Ñö.nn √∑ ‚Ñö.p : ‚Ñö.nn';
		op: '‚Ñö.p √∑ ‚Ñö.p : ‚Ñö.p';
		op: '‚Ñö.nz^(‚Ñ§.nz) : ‚Ñö.nz';
		op: '‚Ñö.p^(‚Ñ§.nz) : ‚Ñö.p';
		op: '‚Ñö.nz^(zero) : ‚Ñï.nz';
		op: 'abs(‚Ñö) : ‚Ñö.nn';
		op: 'abs(‚Ñö.nz) : ‚Ñö.p';
		"Comparison operators"
		op: '‚Ñö < ‚Ñö : ùîπ';
		op: '‚Ñö > ‚Ñö : ùîπ';
		op: '‚Ñö ‚â§ ‚Ñö : ùîπ';
		op: '‚Ñö ‚â• ‚Ñö : ùîπ'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: '‚àÄ x_:‚Ñö ‚àÄ z_:zero x_ + z_ ‚áí x_';
		rule: '‚àÄ x_:‚Ñö ‚àÄ z_:zero z_ + x_ ‚áí x_';
		"Subtraction rules"
		rule: '‚àÄ x_:‚Ñö ‚àÄ z_:zero x_ - z_ ‚áí x_';
		rule: '‚àÄ x_:‚Ñö ‚àÄ z_:zero z_ - x_ ‚áí -(x_)';
		"Negation rules"
		rule: '‚àÄ z_:zero -(z_) ‚áí 0';
		"Multiplication rules"
		rule: '‚àÄ x_:‚Ñö ‚àÄ z_:zero x_ √ó z_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñö ‚àÄ z_:zero z_ √ó x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñö 1 √ó x_ ‚áí x_';
		rule: '‚àÄ x_:‚Ñö x_ √ó 1 ‚áí x_';
		"Division rules"
		rule: '‚àÄ x_:‚Ñö.nz ‚àÄ z_:zero z_ √∑ x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñö x_ √∑ 1 ‚áí x_';
		"Integer div and rem rules"
		rule: '‚àÄ x_:‚Ñ§.nz ‚àÄ z_:zero z_ div x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñ§ x_ div 1 ‚áí x_';
		rule: '‚àÄ x_:‚Ñ§.nz ‚àÄ z_:zero z_ rem x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñ§ x_ rem 1 ‚áí 0';
		"Exponentiation rules"
		rule: '‚àÄ x_:‚Ñö.nz ‚àÄ z_:zero x_^(z_) ‚áí 1';
		rule: '‚àÄ x_:‚Ñï.nz ‚àÄ z_:zero z_^(x_) ‚áí 0';
		"Abs rules"
		rule: '‚àÄ x_:‚Ñö.nn abs(x_) ‚áí x_';
		rule: '‚àÄ x_:‚Ñö abs(x_) ‚áí -(x_) | x_ < 0';
		"Comparison rules"
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ < y_ ‚Üí ''x < y'':LzBooleanTerm';
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ > y_ ‚Üí ''x > y'':LzBooleanTerm';
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ ‚â§ y_ ‚Üí ''x <= y'':LzBooleanTerm';
		rule: '‚àÄ x_:‚Ñö ‚àÄ y_:‚Ñö x_ ‚â• y_ ‚Üí ''x >= y'':LzBooleanTerm'.
	self rationalNumberBuiltinRulesFor: aContextBuilder
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberSortsFor: aContextBuilder [
	aContextBuilder
		"Rational numbers"
		sort: '‚Ñö';
		sort: '‚Ñö.nn';
		sort: '‚Ñö.nz';
		sort: '‚Ñö.p';
		subsort: '‚Ñö.nz ‚äÜ ‚Ñö';
		subsort: '‚Ñö.p ‚äÜ ‚Ñö.nz';
		subsort: '‚Ñö.nn ‚äÜ ‚Ñö';
		subsort: '‚Ñö.p ‚äÜ ‚Ñö.nn';
		subsort: '‚Ñï ‚äÜ ‚Ñö.nn';
		subsort: '‚Ñï.nz ‚äÜ ‚Ñö.p';
		subsort: '‚Ñ§ ‚äÜ ‚Ñö';
		subsort: '‚Ñ§.nz ‚äÜ ‚Ñö.nz'.
]

{ #category : #defining }
LzBuiltinContexts class >> realNumberArrayContext [
	| builder |
	builder := LzContextBuilder new
		include: self arrayMap2Context;
		include: self arrayFoldContext;
		include: self realNumberContext.
	self numberArrayOpsAndRulesForBuilder: builder sort: '‚Ñù'.
	^ builder context
]

{ #category : #private }
LzBuiltinContexts class >> realNumberAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù  x_ + y_ = y_ + x_';
		axiom: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù  ‚àÄ z_:‚Ñù  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù  x_ √ó y_ = y_ √ó x_';
		axiom: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù  ‚àÄ z_:‚Ñù  (x_ √ó y_) √ó z_ = x_ √ó (y_ √ó z_)';
		"distribution"
		axiom: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù  ‚àÄ z_:‚Ñù  x_ √ó (y_ + z_) = (x_ √ó y_) + (x_ √ó z_)'.
]

{ #category : #defining }
LzBuiltinContexts class >> realNumberContext [
	RealNumberContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers;
			builtin: #rationalNumbers.
		self integerSortsFor: builder.
		self rationalNumberSortsFor: builder.
		self realNumberSortsFor: builder.
		self integerOpsFor: builder.
		self rationalNumberOpsFor: builder.
		self realNumberOpsFor: builder.
		"No rationalNumberAxioms, because they would be redundant."
		self realNumberAxiomsFor: builder.
		"No rationalNumberRules, the few that are required are repeated in realNumberRules."
		self realNumberRulesFor: builder.
		RealNumberContext := builder context ].
	^ RealNumberContext
]

{ #category : #private }
LzBuiltinContexts class >> realNumberOpsFor: builder [
	builder
		"Arithmetic operators"
		op: '‚Ñù + ‚Ñù : ‚Ñù';
		op: '‚Ñù.p + ‚Ñù.p : ‚Ñù.p';
		op: '‚Ñù.nn + ‚Ñù.nn : ‚Ñù.nn';
		op: '‚Ñù - ‚Ñù : ‚Ñù';
		op: '-(‚Ñù) : ‚Ñù';
		op: '‚Ñù √ó ‚Ñù : ‚Ñù';
		op: '‚Ñù.p √ó ‚Ñù.p : ‚Ñù.p';
		op: '‚Ñù.nn √ó ‚Ñù.nn : ‚Ñù.nn';
		op: '‚Ñù √∑ ‚Ñù.nz : ‚Ñù';
		op: '‚Ñù.nz √∑ ‚Ñù.nz : ‚Ñù.nz';
		op: '‚Ñù.p √∑ ‚Ñù.p : ‚Ñù.p';
		op: '‚Ñù.nn √∑ ‚Ñù.p : ‚Ñù.nn';
		op: '‚Ñù.nz^(zero) : ‚Ñï.nz';
		op: '‚Ñù.p^(‚Ñù.nz) : ‚Ñù.p';
		op: '‚Ñù.nz^(‚Ñ§.nz) : ‚Ñù.nz';
		op: '‚Ñù^(‚Ñï.nz) : ‚Ñù';
		"Various functions"
		op: 'abs(‚Ñù) : ‚Ñù.nn';
		op: 'abs(‚Ñù.nz) : ‚Ñù.p';
		op: '‚àö(‚Ñù.nn) : ‚Ñù.nn';
		op: '‚àö(‚Ñù.p) : ‚Ñù.p';
		"Comparison operators"
		op: #'‚Ñù < ‚Ñù : ùîπ';
		op: #'‚Ñù > ‚Ñù : ùîπ';
		op: #'‚Ñù ‚â§ ‚Ñù : ùîπ';
		op: #'‚Ñù ‚â• ‚Ñù : ùîπ'.
]

{ #category : #private }
LzBuiltinContexts class >> realNumberRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: '‚àÄ x_:‚Ñù ‚àÄ zero_:zero x_ + zero_ ‚áí x_';
		rule: '‚àÄ x_:‚Ñù ‚àÄ zero_:zero zero_ + x_ ‚áí x_';
		"Subtraction rules"
		rule: '‚àÄ x_:‚Ñù ‚àÄ zero_:zero x_ - zero_ ‚áí x_';
		rule: '‚àÄ x_:‚Ñù ‚àÄ zero_:zero zero_ - x_ ‚áí -(x_)';
		"Negation rules"
		rule: '‚àÄ zero_:zero -(zero_) ‚áí 0';
		"Multiplication rules"
		rule: '‚àÄ x_:‚Ñù ‚àÄ zero_:zero x_ √ó zero_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñù ‚àÄ zero_:zero zero_ √ó x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñù 1 √ó x_ ‚áí x_';
		rule: '‚àÄ x_:‚Ñù x_ √ó 1 ‚áí x_';
		"Division rules"
		rule: '‚àÄ x_:‚Ñù.nz ‚àÄ zero_:zero zero_ √∑ x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñù x_ √∑ 1 ‚áí x_';
		"Integer div and rem rules"
		rule: '‚àÄ x_:‚Ñ§.nz ‚àÄ z_:zero z_ div x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñ§ x_ div 1 ‚áí x_';
		rule: '‚àÄ x_:‚Ñ§.nz ‚àÄ z_:zero z_ rem x_ ‚áí 0';
		rule: '‚àÄ x_:‚Ñ§ x_ rem 1 ‚áí 0';
		"Exponentiation rules"
		rule: '‚àÄ x_:‚Ñù.nz ‚àÄ zero_:zero x_^(zero_) ‚áí 1';
		rule: '‚àÄ x_:‚Ñï.nz ‚àÄ z_:zero z_^(x_) ‚áí 0';
		"Abs rules"
		rule: '‚àÄ x_:‚Ñù.nn abs(x_) ‚áí x_';
		rule: '‚àÄ x_:‚Ñù abs(x_) ‚áí -(x_) | x_ < 0';
		"Comparison rules"
		rule: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù x_ < y_ ‚Üí ''x < y'':LzBooleanTerm';
		rule: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù x_ > y_ ‚Üí ''x > y'':LzBooleanTerm';
		rule: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù x_ ‚â§ y_ ‚Üí ''x <= y'':LzBooleanTerm';
		rule: '‚àÄ x_:‚Ñù ‚àÄ y_:‚Ñù x_ ‚â• y_ ‚Üí ''x >= y'':LzBooleanTerm'.
	self rationalNumberBuiltinRulesFor: aContextBuilder
]

{ #category : #private }
LzBuiltinContexts class >> realNumberSortsFor: builder [
	builder
		sort: '‚Ñù';
		sort: '‚Ñù.nz';
		sort: '‚Ñù.nn';
		sort: '‚Ñù.p';
		subsort: '‚Ñö ‚äÜ ‚Ñù';
		subsort: '‚Ñù.nz ‚äÜ ‚Ñù';
		subsort: '‚Ñö.nz ‚äÜ ‚Ñù.nz';
		subsort: '‚Ñù.p ‚äÜ ‚Ñù.nz';
		subsort: '‚Ñö.p ‚äÜ ‚Ñù.p';
		subsort: '‚Ñù.nn ‚äÜ ‚Ñù';
		subsort: '‚Ñù.p ‚äÜ ‚Ñù.nn';
		subsort: '‚Ñö.nn ‚äÜ ‚Ñù.nn'.
]

{ #category : #resetting }
LzBuiltinContexts class >> reset [
	TruthContext := nil.
	EqualityContext := nil.
	IntegerContext := nil.
	RationalNumberContext := nil.
	RealNumberContext := nil.
	StringContext := nil.
	ArrayContext := nil.
]

{ #category : #defining }
LzBuiltinContexts class >> sortContext [
	^ LzSortHierarchyRoot uniqueInstance sortContext
]

{ #category : #defining }
LzBuiltinContexts class >> stringContext [
	StringContext ifNil: [
		StringContext :=
			LzContextBuilder new
				builtin: #strings;
				sort: 'string';
				op: 'string + string : string';
				rule: '‚àÄ a_:string ‚àÄ b_:string a_ + b_ ‚Üí ''a, b'':LzStringTerm';
				context ].
	^ StringContext
]

{ #category : #defining }
LzBuiltinContexts class >> truthContext [
	TruthContext ifNil: [
		TruthContext :=
			LzContextBuilder new
				sort: 'ùîπ';
				op: '‚ä§ : ùîπ';
				op: '‚ä• : ùîπ';
				context ].
	^ TruthContext
]
