"
The contexts defined in the methods of this class are standard Leibniz contexts. They are provided because they are useful and/or because they are used in other example code.
"
Class {
	#name : #LzExampleContexts,
	#superclass : #Object,
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #defining }
LzExampleContexts class >> booleanContext [
	| builder |
	builder := LzContextBuilder new
		include: LzBuiltinContexts truthContext;
		op: 'Â¬(ğ”¹) : ğ”¹';
		op: 'ğ”¹ âˆ§ ğ”¹ : ğ”¹';
		op: 'ğ”¹ âˆ¨ ğ”¹ : ğ”¹';
		op: 'ğ”¹ âŠ» ğ”¹ : ğ”¹';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ x_ âˆ§ y_ = y_ âˆ§ x_';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ (x_ âˆ§ y_) âˆ§ z_ = x_ âˆ§ (y_ âˆ§ z_)';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ x_ âˆ¨ y_ = y_ âˆ¨ x_';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ (x_ âˆ¨ y_) âˆ¨ z_ = x_ âˆ¨ (y_ âˆ¨ z_)';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ x_ âŠ» y_ = y_ âŠ» x_';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ (x_ âŠ» y_) âŠ» z_ = x_ âŠ» (y_ âŠ» z_)'.
	self booleanRulesFor: builder.
	^ builder context
]

{ #category : #private }
LzExampleContexts class >> booleanRulesFor: builder [
	builder
		"1. Eliminate NOT and OR"

		"1a. NOT is replaced by XOR with âŠ¤"
		rule: 'âˆ€ x_:ğ”¹ Â¬(x_) â‡’ âŠ¤ âŠ» x_';

		"1b. OR is replaced by XOR and AND"
		rule: 'âˆ€ y_:ğ”¹  âˆ€ x_:ğ”¹ x_ âˆ¨ y_ â‡’ x_ âŠ» y_ âŠ» (x_ âˆ§ y_)';

		"2 Simplify AND relations"

		"2a. AND is âŠ¥ if one of its arguments is âŠ¥"
		rule: 'âˆ€ x_:ğ”¹ x_ âˆ§ âŠ¥ â‡’ âŠ¥';
		rule: 'âˆ€ x_:ğ”¹ âŠ¥ âˆ§ x_ â‡’ âŠ¥';

		"2b. If one argument of AND is âŠ¤, the result is the other argument"
		rule: 'âˆ€ x_:ğ”¹ x_ âˆ§ âŠ¤ â‡’ x_';
		rule: 'âˆ€ x_:ğ”¹ âŠ¤ âˆ§ x_ â‡’ x_';

		"2c. If the two arguments to AND are equal, they are also equal to the result"
		rule: 'âˆ€ x_:ğ”¹ x_ âˆ§ x_ â‡’ x_';

		"3 Simplify XOR relations"

		"3a. XOR with âŠ¥ leaves truth values unchanged"
		rule: 'âˆ€ x_:ğ”¹ x_ âŠ» âŠ¥ â‡’ x_';
		rule: 'âˆ€ x_:ğ”¹ âŠ¥ âŠ» x_ â‡’ x_';

		"3b. If the two arguments to XOR are equal, the result is âŠ¥"
		rule: 'âˆ€ x_:ğ”¹ x_ âŠ» x_ â‡’ âŠ¥';

		"4. Standardize combinations of XOR and AND"
		rule: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ x_ âˆ§ (y_ âŠ» z_) â‡’ (x_ âˆ§ y_) âŠ» (x_ âˆ§ z_)'.
]
