Class {
	#name : #LzExamples,
	#superclass : #Object,
	#traits : 'TGtExampleAssertable',
	#classTraits : 'TGtExampleAssertable classTrait',
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #example }
LzExamples >> bagContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listContext;
		include: (LzBook contextNamed: 'Integers');
		sort: 'collection';
		sort: 'bag(ð•Š, â„•)';
		subsort: 's_:ð•Š, n_:â„•, list(s_, n_) âŠ† bag(s_, n_)';
		subsort: 's_:ð•Š, n_:â„•, bag(s_, n_) âŠ† collection';
		subsort: 'âˆ… âŠ† collection';
		op: 's_:ð•Š, n_:â„•, m_:â„•, (bag(s_, n_)) ** (bag(s_, m_)) : bag(s_, n_ + m_)';
		op: 's_:ð•Š, n_:â„•, (bag(s_, n_)) ** s_ : bag(s_, n_ + 1)';
		op: 's_:ð•Š, âˆ… ** s_ : bag(s_, 1)';
		op: 'size(collection) : â„•';
		context
]

{ #category : #example }
LzExamples >> bagRules [
	<gtExample>
	| context |
	context := self bagContext.
	^ {
		'âˆ… ++ 1 â‡’ âˆ…'.
		'size(âˆ…) â‡’ 0'.
	} collect: [ :each |
		| rule |
		rule := context rule: each.
		self assert: rule asLeibnizSyntaxString equals: each.
		rule ]
]

{ #category : #example }
LzExamples >> bagSignature [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self bagSortGraph;
		include: self listSignature;
		op: 's_:ð•Š, n_:â„•, m_:â„•, (bag(s_, n_)) ** (bag(s_, m_)) : bag(s_, n_ + m_)';
		op: 's_:ð•Š, n_:â„•, (bag(s_, n_)) ** s_ : bag(s_, n_ + 1)';
		op: 's_:ð•Š, âˆ… ** s_ : bag(s_, 1)';
		signature

]

{ #category : #example }
LzExamples >> bagSortContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listSortContext;
		op: 'collection : ð•Š';
		op: 'bag(ð•Š, â„•) : ð•Š';
		op: 'â„• : ð•Š';
		axiom: 's_:ð•Š, n_:â„•, list(s_, n_) âŠ† bag(s_, n_)';
		axiom: 's_:ð•Š, n_:â„•, bag(s_, n_) âŠ† collection';
		axiom: 'âˆ… âŠ† collection';
		context
]

{ #category : #example }
LzExamples >> bagSortGraph [
	<gtExample>
	^ LzSortGraphBuilder new
		sortContext: self bagSortContext;
		sortGraph
]

{ #category : #example }
LzExamples >> listContext [
	<gtExample>
	^ LzContextBuilder new
		includeSortContext: (LzBook contextNamed: 'Integers');
		sort: 'element';
		sort: 'element.special';
		sort: 'âˆ…';
		sort: 'list(ð•Š, â„•)';
		subsort: 'element.special âŠ† element';		
		op: 'âˆ… : âˆ…';
		op: 's_:ð•Š, n_:â„•, m_:â„•, ',
				'(list(s_, n_)) ++ (list(s_, m_)) : list(s_, n_ + m_)';
		op: 's_:ð•Š, n_:â„•, ',
				'(list(s_, n_)) ++ s_ : list(s_, n_ + 1)';
		op: 's_:ð•Š, ',
				'âˆ… ++ s_ : list(s_, 1)';
		op: 's_:ð•Š, n_:â„•.nz, ',
				'first(list(s_, n_)) : s_';
		op: 'anElement : element';
		op: 'aSpecialElement : element.special';
		rule: 's__:ð•Š, e_:s__, first(âˆ… ++ e_) â‡’ e_';
		context

]

{ #category : #example }
LzExamples >> listOfIntegerTerms [
	<gtExample>
	| context |
	context := self listPlusIntegerContext.
	^ {
		'âˆ…'.
		'âˆ… ++ 1'.
		'âˆ… ++ 1 ++ 2'.
		'first(âˆ… ++ 1)'.
	}
	collect: [ :each |
		 context term: each ]
]

{ #category : #example }
LzExamples >> listPlusIntegerContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listContext;
		include: (LzBook contextNamed: 'Integers');
		include: (LzBook contextNamed: 'Term equality');
		context
]

{ #category : #example }
LzExamples >> listSignature [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self listSortGraph;
		op: 'âˆ… : âˆ…';
		op: 's_:ð•Š, n_:â„•, m_:â„•, ',
				'(list(s_, n_)) ++ (list(s_, m_)) : list(s_, n_ + m_)';
		op: 's_:ð•Š, n_:â„•, ',
				'(list(s_, n_)) ++ s_ : list(s_, n_ + 1)';
		op: 's_:ð•Š, ',
				'âˆ… ++ s_ : list(s_, 1)';
		op: 'anElement : element';
		signature
]

{ #category : #example }
LzExamples >> listSortContext [
	<gtExample>
	^ (LzContextBuilder new
		include: LzSortHierarchyRoot uniqueInstance sortContext;
		include: (LzBook contextNamed: 'Integers');
		op: 'element : ð•Š';
		op: 'element.special : ð•Š';
		op: 'âˆ… : ð•Š';
		op: 'list(ð•Š, â„•) : ð•Š';
		axiom: 'element.special âŠ† element')
		context.
]

{ #category : #example }
LzExamples >> listSortGraph [
	<gtExample>
	^ LzSortGraphBuilder new
		sortContext: self listSortContext;
		sortGraph
]

{ #category : #example }
LzExamples >> listTermRewrites [
	<gtExample>
	| context |
	context := self listPlusIntegerContext.
	^ {
		'first(âˆ… ++ 1)'.
	}
	collect: [ :each |
		| term rewrittenTerm |
		term := context term: each.
		rewrittenTerm := context reduce: term.
		{ term. rewrittenTerm } ]
]

{ #category : #example }
LzExamples >> listTerms [
	<gtExample>
	| context |
	context := self listContext.
	^ {
		{ 'âˆ…'. 'âˆ…' }.
		{ 'âˆ… ++ anElement'. 'list(element, 1)' }.
		{ 'âˆ… ++ aSpecialElement'. 'list(element.special, 1)' }.
		{ 'âˆ… ++ anElement ++ aSpecialElement'. 'list(element, 2)' }.
		{ 'âˆ… ++ aSpecialElement ++ anElement'. 'list(element, 2)' }.
		{ 'first(âˆ… ++ anElement)'. 'element' }.
		{ 'first(âˆ… ++ aSpecialElement)'. 'element.special'}.
	}
	collect: [ :each |
		| term sort |
		 term := context term: each first.
		 sort := context sort: each second.
		 self assert: term sort equals: sort.
		 term ]
]

{ #category : #accessing }
LzExamples >> signatureWithSubsorts [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self sortGraphWithSubsorts;
		op: 'anA : A';
		op: 'aB : B';
		op: 'aC : C';
		op: 'aD : D';
		op: 'foo(A) : A';
		signature
]

{ #category : #example }
LzExamples >> simpleContext [
	<gtExample>
	^ self simpleContextBuilder context
]

{ #category : #example }
LzExamples >> simpleContextBuilder [
	<gtExample>
	^ LzContextBuilder new
		sort: 'Foo';
		op: 'aFoo : Foo';
		op: 'aFoo(Foo) : Foo';
		op: 'Foo + Foo : Foo';
		op: 'Foo[Foo] : Foo';
		op: 'Foo^(Foo) : Foo';
		op: 'Foo\(Foo) : Foo'.
]

{ #category : #example }
LzExamples >> simpleContextRules [
	<gtExample>
	^ {
		'aFoo â‡’ aFoo'.
		'aFoo(aFoo) â‡’ aFoo'.
		'someFoo_:Foo, aFoo(someFoo_) â‡’ someFoo_'.
	} collect: [ :each |
		| rule |
		rule := self simpleContext rule: each.
		self assert: rule asLeibnizSyntaxString equals: each.
		rule ]
]

{ #category : #example }
LzExamples >> simpleContextTermMatches [
	<gtExample>
	| context |
	context := self simpleContext.
	^ {
		{ 'foo_:Foo, foo_'. 'aFoo'.  {'foo_' -> 'aFoo'} }.
		{ 'foo_:Foo, foo_'. 'aFoo(aFoo)'.  {'foo_' -> 'aFoo(aFoo)'} }.
		{ 'foo_:Foo, aFoo(foo_)'. 'aFoo(aFoo)'. {'foo_' -> 'aFoo'} }.
		{ 'foo_:Foo, (foo_ + foo_)'. 'aFoo + aFoo'. {'foo_' -> 'aFoo'} }.
		{ 'foo_:Foo, aFoo(foo_)'. 'aFoo'. {} }
	} collect: [ :each |
		| pattern term bindings result |
		pattern := context pattern: each first.
		term := context term: each second.
		bindings := pattern match: term.
		result := each third collect: [ :eachEntry |
					(LzVarName for: eachEntry key)
						-> (context term: eachEntry value) ].
		self assert: bindings bindings equals: result asDictionary.
		bindings ]
]

{ #category : #example }
LzExamples >> simpleContextTerms [
	<gtExample>
	^ {
		'aFoo'.
		'aFoo(aFoo)'.
		'aFoo(aFoo + aFoo)'.
		'aFoo[aFoo]'.
		'aFoo^(aFoo)'.
		'aFoo\(aFoo)'
	} collect: [ :each |
		| term |
		term := self simpleContext term: each.
		self assert: term asLeibnizSyntaxString equals: each.
		term ]
]

{ #category : #example }
LzExamples >> sortGraphWithSubsorts [
	<gtExample>
	| sortGraph |
	sortGraph := (LzSortGraphBuilder new
		sort: 'A';
		sort: 'B';
		sort: 'C';
		sort: 'D';
		subsort: 'B âŠ† A';
		subsort: 'C âŠ† A';
		subsort: 'D âŠ† B';
		subsort: 'D âŠ† C')
		sortGraph.
	self assert: (sortGraph sort: 'B') <= (sortGraph sort: 'A').
	self assert: (sortGraph sort: 'C') <= (sortGraph sort: 'A').
	self assert: (sortGraph sort: 'D') <= (sortGraph sort: 'A').
	self assert: ((sortGraph sort: 'A') <= (sortGraph sort: 'B')) not.
	self assert: ((sortGraph sort: 'B') <= (sortGraph sort: 'C')) not.
	self assert: ((sortGraph sort: 'C') <= (sortGraph sort: 'B')) not.
	^ sortGraph
]

{ #category : #example }
LzExamples >> termsForSignatureWithSubsorts [
	<gtExample>
	^ {
		'anA'. 'aB'. 'aC'. 'aD'.
		'foo(anA)'. 'foo(aB)'. 'foo(aC)'. 'foo(aD)'.
	} collect: [ :each |
		self signatureWithSubsorts term: each ]
]
