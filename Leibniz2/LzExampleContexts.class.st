"
The contexts defined in the methods of this class are standard Leibniz contexts. They are provided because they are useful and/or because they are used in other example code.
"
Class {
	#name : #LzExampleContexts,
	#superclass : #Object,
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #defining }
LzExampleContexts class >> booleanContext [
	| builder |
	builder := LzContextBuilder new
		include: LzBuiltinContexts truthContext;
		op: 'Â¬(ğ”¹) : ğ”¹';
		op: 'ğ”¹ âˆ§ ğ”¹ : ğ”¹';
		op: 'ğ”¹ âˆ¨ ğ”¹ : ğ”¹';
		op: 'ğ”¹ âŠ» ğ”¹ : ğ”¹';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ x_ âˆ§ y_ = y_ âˆ§ x_';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ (x_ âˆ§ y_) âˆ§ z_ = x_ âˆ§ (y_ âˆ§ z_)';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ x_ âˆ¨ y_ = y_ âˆ¨ x_';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ (x_ âˆ¨ y_) âˆ¨ z_ = x_ âˆ¨ (y_ âˆ¨ z_)';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ x_ âŠ» y_ = y_ âŠ» x_';
		axiom: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ (x_ âŠ» y_) âŠ» z_ = x_ âŠ» (y_ âŠ» z_)'.
	self booleanRulesFor: builder.
	^ builder context
]

{ #category : #private }
LzExampleContexts class >> booleanRulesFor: builder [
	builder
		"1. Eliminate NOT and OR"

		"1a. NOT is replaced by XOR with âŠ¤"
		rule: 'âˆ€ x_:ğ”¹ Â¬(x_) â‡’ âŠ¤ âŠ» x_';

		"1b. OR is replaced by XOR and AND"
		rule: 'âˆ€ y_:ğ”¹  âˆ€ x_:ğ”¹ x_ âˆ¨ y_ â‡’ x_ âŠ» y_ âŠ» (x_ âˆ§ y_)';

		"2 Simplify AND relations"

		"2a. AND is âŠ¥ if one of its arguments is âŠ¥"
		rule: 'âˆ€ x_:ğ”¹ x_ âˆ§ âŠ¥ â‡’ âŠ¥';
		rule: 'âˆ€ x_:ğ”¹ âŠ¥ âˆ§ x_ â‡’ âŠ¥';

		"2b. If one argument of AND is âŠ¤, the result is the other argument"
		rule: 'âˆ€ x_:ğ”¹ x_ âˆ§ âŠ¤ â‡’ x_';
		rule: 'âˆ€ x_:ğ”¹ âŠ¤ âˆ§ x_ â‡’ x_';

		"2c. If the two arguments to AND are equal, they are also equal to the result"
		rule: 'âˆ€ x_:ğ”¹ x_ âˆ§ x_ â‡’ x_';

		"3 Simplify XOR relations"

		"3a. XOR with âŠ¥ leaves truth values unchanged"
		rule: 'âˆ€ x_:ğ”¹ x_ âŠ» âŠ¥ â‡’ x_';
		rule: 'âˆ€ x_:ğ”¹ âŠ¥ âŠ» x_ â‡’ x_';

		"3b. If the two arguments to XOR are equal, the result is âŠ¥"
		rule: 'âˆ€ x_:ğ”¹ x_ âŠ» x_ â‡’ âŠ¥';

		"4. Standardize combinations of XOR and AND"
		rule: 'âˆ€ x_:ğ”¹ âˆ€ y_:ğ”¹ âˆ€ z_:ğ”¹ x_ âˆ§ (y_ âŠ» z_) â‡’ (x_ âˆ§ y_) âŠ» (x_ âˆ§ z_)'.
]

{ #category : #private }
LzExampleContexts class >> collectionConstructorOpsFor: builder [
	builder
		op: 'âˆ… : âˆ…';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• âˆ€ m_:â„• ',
				'(list(s_, n_)) ++ (list(s_, m_)) : list(s_, n_ + m_)';
		op: 'âˆ€ s_:ğ•Š ',
				'(list(s_)) ++ (list(s_)) : list(s_)';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• âˆ€ m_:â„• ',
				'(bag(s_, n_)) ++ (bag(s_, m_)) : bag(s_, n_ + m_)';
		op: 'âˆ€ s_:ğ•Š ',
				'(bag(s_)) ++ (bag(s_)) : bag(s_)';
		op: 'âˆ€ s_:ğ•Š ',
				'(set(s_)) ++ (set(s_)) : set(s_)';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• ',
				'(list(s_, n_)) ++ s_ : list(s_, n_ + 1)';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• ',
				'(bag(s_, n_)) ++ s_ : bag(s_, n_ + 1)';
		op: 'âˆ€ s_:ğ•Š ',
				'(list(s_)) ++ s_ : list(s_)';
		op: 'âˆ€ s_:ğ•Š ',
				'(bag(s_)) ++ s_ : bag(s_)';
		op: 'âˆ€ s_:ğ•Š ',
				'(set(s_)) ++ s_ : set(s_)';
		op: 'âˆ€ s_:ğ•Š ',
				'âˆ… ++ s_ : list(s_, 1)';
		op: 'âˆ€ s_:ğ•Š ',
				'singleton(s_) : list(s_, 1)'
]

{ #category : #defining }
LzExampleContexts class >> collectionContext [
	| builder |
	builder := LzContextBuilder new
		includeSortContext: LzBuiltinContexts integerContext.
	self collectionSortsFor: builder. 
	self collectionConstructorOpsFor: builder.
	self constructionAccessorsFor: builder.
	^ builder context
]

{ #category : #private }
LzExampleContexts class >> collectionSortsFor: builder [
	builder
		sort: 'collection';
		sort: 'âˆ…';
		subsort: 'âˆ… âŠ† collection';
		sort: 'list(ğ•Š, â„•)';
		sort: 'bag(ğ•Š, â„•)';
		sort: 'list(ğ•Š)';
		sort: 'bag(ğ•Š)';
		sort: 'set(ğ•Š)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• list(s_, n_) âŠ† bag(s_, n_)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• list(s_, n_) âŠ† list(s_)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• bag(s_, n_) âŠ† bag(s_)';
		subsort: 'âˆ€ s_:ğ•Š list(s_) âŠ† bag(s_)';
		subsort: 'âˆ€ s_:ğ•Š bag(s_) âŠ† set(s_)';
		subsort: 'âˆ€ s_:ğ•Š set(s_) âŠ† collection'
]

{ #category : #private }
LzExampleContexts class >> constructionAccessorsFor: builder [
	builder
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„•.nz ',
				'allButLast(list(s_, n_)) : list(s_, pred(n_))';
		rule: 'âˆ€ s__:ğ•Š âˆ€ n__:â„• âˆ€ l_:list(s__, n__) âˆ€ e_:s__ ',
				'allButLast(l_ ++ e_) â‡’ l_';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„•.nz ',
				'last(list(s_, n_)) : s_';
		rule: 'âˆ€ s__:ğ•Š âˆ€ n__:â„• âˆ€ l_:list(s__, n__) âˆ€ e_:s__ ',
				'last(l_ ++ e_) â‡’ e_'
]

{ #category : #private }
LzExampleContexts class >> geometricAlgebra3DBasisFor: builder [
	builder
		op: 'e1 : Vector';
		op: 'e2 : Vector';
		op: 'e3 : Vector';
		rule: 'e1 Ã— e1 â‡’ 1';
		rule: 'e2 Ã— e2 â‡’ 1';
		rule: 'e3 Ã— e3 â‡’ 1';
		axiom: 'e1 Ã— e2 = -(e2 Ã— e1)';
		axiom: 'e2 Ã— e3 = -(e3 Ã— e2)';
		axiom: 'e3 Ã— e1 = -(e1 Ã— e3)';

		op: 'i : Pseudoscalar';
		rule: 'i Ã— i â‡’ -1';
		axiom: 'i = e1 Ã— e2 Ã— e3';
		axiom: 'âˆ€ x_:Multivector i Ã— x_ = x_ Ã— i';
		axiom: 'e1 Ã— e2 = i Ã— e3';
		axiom: 'e2 Ã— e3 = i Ã— e1';
		axiom: 'e3 Ã— e1 = i Ã— e2';

		op: 'v(â„, â„, â„) : Vector';
		axiom: 'âˆ€ x_:â„ âˆ€ y_:â„ âˆ€ z_:â„ ',
				'v(x_, y_, z_) = ((x_ Ã— e1) + (y_ Ã— e2) + (z_ Ã— e3))'
]

{ #category : #defining }
LzExampleContexts class >> geometricAlgebra3DContext [
	| builder |
	builder := LzContextBuilder new
		include: LzBuiltinContexts realNumberContext.
	self geometricAlgebra3DSortsFor: builder.
	self geometricAlgebra3DSumsFor: builder.
	self geometricAlgebra3DProductsFor: builder.
	self geometricAlgebra3DBasisFor: builder.
	self geometricAlgebra3DSimplificationsFor: builder.
	^ builder context
]

{ #category : #private }
LzExampleContexts class >> geometricAlgebra3DProductsFor: builder [
	builder
		op: 'Multivector Ã— Multivector : Multivector';
		op: 'â„ Ã— Vector : Vector';
		op: 'Vector Ã— â„ : Vector';
		op: 'â„ Ã— Bivector : Bivector';
		op: 'Bivector Ã— â„ : Bivector';
		op: 'â„ Ã— Pseudoscalar : Pseudoscalar';
		op: 'Pseudoscalar Ã— â„ : Pseudoscalar';
		op: 'Vector Ã— Pseudoscalar : Bivector';
		op: 'Pseudoscalar Ã— Vector : Bivector';
		op: 'Bivector Ã— Pseudoscalar : Vector';
		op: 'Pseudoscalar Ã— Bivector : Vector';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector âˆ€ z_:Multivector  (x_ Ã— y_) Ã— z_ = x_ Ã— (y_ Ã— z_)';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector âˆ€ z_:Multivector  x_ Ã— (y_ + z_) = (x_ Ã— y_) + (x_ Ã— z_)';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector âˆ€ z_:Multivector  (x_ + y_) Ã— z_ = (x_ Ã— z_) + (y_ Ã— z_)';
		rule: 'âˆ€ x_:Multivector 1 Ã— x_ â‡’ x_';
		rule: 'âˆ€ x_:Multivector x_ Ã— 1 â‡’ x_';
		rule: 'âˆ€ zero_:zero âˆ€ x_:Multivector zero_ Ã— x_ â‡’ 0';
		rule: 'âˆ€ zero_:zero âˆ€ x_:Multivector x_ Ã— zero_ â‡’ 0';

		op: 'Multivector âˆ§ Multivector : Multivector';
		op: 'â„ âˆ§ Vector : Vector';
		op: 'Vector âˆ§ â„ : Vector';
		op: 'Vector âˆ§ Vector : Bivector';
		op: 'Vector âˆ§ Bivector : Pseudoscalar';
		op: 'Bivector âˆ§ Vector : Pseudoscalar';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector x_ âˆ§ y_ = -(y_ âˆ§ x_)';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector âˆ€ z_:Multivector  (x_ âˆ§ y_) âˆ§ z_ = x_ âˆ§ (y_ âˆ§ z_)';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector âˆ€ z_:Multivector  x_ âˆ§ (y_ + z_) = (x_ âˆ§ y_) + (x_ âˆ§ z_)';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector âˆ€ z_:Multivector  (x_ + y_) âˆ§ z_ = (x_ âˆ§ z_) + (y_ âˆ§ z_)';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector x_ âˆ§ y_ = 1/2 Ã— ((x_ Ã— y_) - (y_ Ã— x_))';
		rule: 'âˆ€ x_:Multivector 1 âˆ§ x_ â‡’ x_';
		rule: 'âˆ€ x_:Multivector x_ âˆ§ 1 â‡’ x_';
		rule: 'âˆ€ zero_:zero âˆ€ x_:Multivector zero_ âˆ§ x_ â‡’ 0';
		rule: 'âˆ€ zero_:zero âˆ€ x_:Multivector x_ âˆ§ zero_ â‡’ 0';
		rule: 'âˆ€ x_:Vector x_ âˆ§ x_ â‡’ 0';

		op: 'Vector â‹… Vector: â„';
		axiom: 'âˆ€ x_:Vector âˆ€ y_:Vector x_ â‹… y_ = 1/2 Ã— ((x_ Ã— y_) + (y_ Ã— x_))';

		op: 'sq(Vector): â„.nn';
		rule: 'âˆ€ x_:Vector x_ Ã— x_ â‡’ sq(x_)';
		rule: 'âˆ€ x_:Vector x_ â‹… x_ â‡’ sq(x_)';

		op: 'norm(Vector): â„.nn';
		axiom: 'âˆ€ v_:Vector norm(v_) = âˆš(sq(v_))'
]

{ #category : #defining }
LzExampleContexts class >> geometricAlgebra3DSimplificationsFor: builder [
	builder
		rule: 'âˆ€ s_:â„ âˆ€ v_:Vector sq(s_ Ã— v_) â‡’ s_^(2) Ã— sq(v_)';
		rule: 'âˆ€ s_:â„ âˆ€ x_:â„ âˆ€ y_:â„ âˆ€ z_:â„ ',
				's_ Ã— v(x_, y_, z_) â‡’ v(s_ Ã— x_, s_ Ã— y_, s_ Ã— z_)';
		rule: 'âˆ€ x1_:â„ âˆ€ y1_:â„ âˆ€ z1_:â„ ',
				'âˆ€ x2_:â„ âˆ€ y2_:â„ âˆ€ z2_:â„ ',
				'v(x1_, y1_, z1_) + v(x2_, y2_, z2_)',
				'â‡’ v(x1_ + x2_, y1_ + y2_, z1_ + z2_)';
		rule: 'âˆ€ x1_:â„ âˆ€ y1_:â„ âˆ€ z1_:â„ ',
				'âˆ€ x2_:â„ âˆ€ y2_:â„ âˆ€ z2_:â„ ',
				'v(x1_, y1_, z1_) - v(x2_, y2_, z2_)',
				'â‡’ v(x1_ - x2_, y1_ - y2_, z1_ - z2_)';
		rule: 'âˆ€ x_:â„ âˆ€ y_:â„ âˆ€ z_:â„ ',
				'sq(v(x_, y_, z_)) â‡’ (x_ Ã— x_) + (y_ Ã— y_) + (z_ Ã— z_)';
		rule: 'âˆ€ x_:â„ âˆ€ y_:â„ âˆ€ z_:â„ ',
				'norm(v(x_, y_, z_)) â‡’ âˆš(sq(v(x_, y_, z_)))'
]

{ #category : #private }
LzExampleContexts class >> geometricAlgebra3DSortsFor: builder [
	builder
		sort: 'Multivector';
		sort: 'Vector';
		sort: 'Bivector';
		sort: 'Pseudoscalar';
		subsort: 'â„ âŠ† Multivector';
		subsort: 'Vector âŠ† Multivector';
		subsort: 'Bivector âŠ† Multivector';
		subsort: 'Pseudoscalar âŠ† Multivector'
]

{ #category : #private }
LzExampleContexts class >> geometricAlgebra3DSumsFor: builder [
	builder
		op: 'Multivector + Multivector : Multivector';
		op: 'Vector + Vector : Vector';
		op: 'Bivector + Bivector : Bivector';
		op: 'Pseudoscalar + Pseudoscalar : Pseudoscalar';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector  x_ + y_ = y_ + x_';
		axiom: 'âˆ€ x_:Multivector âˆ€ y_:Multivector  âˆ€ z_:Multivector  (x_ + y_) + z_ = x_ + (y_ + z_)';

		op: 'Multivector - Multivector : Multivector';
		op: 'Vector - Vector : Vector';
		op: 'Bivector - Bivector : Bivector';
		op: 'Pseudoscalar - Pseudoscalar : Pseudoscalar';

		op: '-(Multivector) : Multivector';
		op: '-(Vector) : Vector';
		op: '-(Bivector) : Bivector';
		op: '-(Pseudoscalar) : Pseudoscalar'
]

{ #category : #defining }
LzExampleContexts class >> mapContext [
	^ LzContextBuilder new
		include: LzBuiltinContexts functionContext;
		include: self collectionContext;
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ n_:â„• ',
			'map(fn(from_, to_), list(from_, n_)) : list(to_, n_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ n_:â„• ',
			'map(fn(from_, to_), âˆ…) : âˆ…';
		rule: 'âˆ€ from__:ğ•Š âˆ€ to__:ğ•Š âˆ€ f_:fn(from__, to__) ',
				'âˆ€ n__:â„• âˆ€ l_:list(from__, n__) âˆ€ e_:from__ ',
				'map(f_, l_ ++ e_) â‡’ map(f_, l_) ++ f_[e_]';
		rule: 'âˆ€ from__:ğ•Š âˆ€ to__:ğ•Š âˆ€ f_:fn(from__, to__) ',
				'âˆ€ e_:from__ ',
				'map(f_, âˆ… ++ e_) â‡’ âˆ… ++ f_[e_]';
		rule: 'âˆ€ from__:ğ•Š âˆ€ to__:ğ•Š âˆ€ f_:fn(from__, to__) ',
				'map(f_, âˆ…) â‡’ âˆ…';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ n_:â„• ',
				'(fn(from_, to_))[list(from_, n_)] : list(to_, n_)';
		rule: 'âˆ€ from__:ğ•Š âˆ€ to__:ğ•Š ',
				'âˆ€ f_:fn(from__, to__) âˆ€ n__:â„•  âˆ€ l_:list(from__, n__) ',
				'f_[l_] â‡’ map(f_, l_)';
		context
]
