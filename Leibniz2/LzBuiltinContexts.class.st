"
Builtin contexts are contexts that cannot be defined in Leibniz itself, because they make use of builtin terms such as numbers or strings. {{gtMethod:name=LzBuiltinContexts class>>#truthContext}} is an exception: it could very well be defined as a standard Leibniz context, but since it is used by the number contexts, it is part of the builtin contexts as well.

"
Class {
	#name : #LzBuiltinContexts,
	#superclass : #Object,
	#classVars : [
		'ArrayContext',
		'EqualityContext',
		'IntegerContext',
		'RationalNumberContext',
		'RealNumberContext',
		'StringContext',
		'TruthContext'
	],
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #defining }
LzBuiltinContexts class >> arrayAppendContext [
	^ LzContextBuilder new
		include: self arrayContext;
		op: 'âˆ€ s_:ğ•Š ',
				'(Array1D(s_)) â§Ÿ (Array1D(s_)) : Array1D(s_)';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• âˆ€ m_:â„• ',
				'(Array(s_, n_)) â§Ÿ (Array(s_, m_)) : Array(s_, n_ + m_)';
		op: 'âˆ€ s_:ğ•Š ',
				'(Array1D(s_)) â§Ÿ (EmptyArray1D) : Array1D(s_)';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ A_:Array1D(s__) âˆ€ B_:Array1D(s__) ',
				'A_ â§Ÿ B_ â†’ ''A ensureArrayTerm. B ensureArrayTerm. A append: B'':nil';
		op: 'âˆ€ s_:ğ•Š ',
				'(EmptyArray1D) â§Ÿ (Array1D(s_)) : Array1D(s_)';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ e_:EmptyArray1D âˆ€ a_:Array1D(s__) ',
				'e_ â§Ÿ a_ â‡’ a_';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ e_:EmptyArray1D âˆ€ a_:Array1D(s__) ',
				'a_ â§Ÿ e_ â‡’ a_';
		op: 'âˆ€ s_:ğ•Š ',
				'(EmptyArray1D) â§Ÿ (EmptyArray1D) : EmptyArray1D';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ e1_:EmptyArray1D âˆ€ e2_:EmptyArray1D ',
				'e1_ â§Ÿ e2_ â‡’ e1_';

		op: 'âˆ€ s_:ğ•Š ',
				'(Array1D(s_)) âŸœ (s_) : Array1D(s_)';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• ',
				'(Array(s_, n_)) âŸœ (s_) : Array(s_, succ(n_))';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ a_:Array1D(s__) âˆ€ v_:s__ ',
				'a_ âŸœ v_ â‡’ a_ â§Ÿ {[ v_ ]}';
		op: 'âˆ€ s_:ğ•Š ',
				'(EmptyArray1D) âŸœ (s_) : Array(s_, 1)';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ e_:EmptyArray1D âˆ€ v_:s__ ',
				'e_ âŸœ v_ â‡’ {[ v_ ]}';

		op: 'âˆ€ s_:ğ•Š ',
				'(s_) âŠ¸ (Array1D(s_)) : Array1D(s_)';
		op: 'âˆ€ s_:ğ•Š âˆ€ n_:â„• ',
				'(s_) âŠ¸ (Array(s_, n_)) : Array(s_, succ(n_))';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ a_:Array1D(s__) âˆ€ v_:s__ ',
				'v_ âŠ¸ a_ â‡’ {[ v_ ]} â§Ÿ a_';
		op: 'âˆ€ s_:ğ•Š ',
				'(s_) âŠ¸ (EmptyArray1D) : Array(s_, 1)';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ e_:EmptyArray1D âˆ€ v_:s__ ',
				'v_ âŠ¸ e_ â‡’ {[ v_ ]}';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayContext [
	ArrayContext ifNil: [
		| builder |
		builder := LzContextBuilder new
					includeSortContext: LzBuiltinContexts integerContext;
					include: LzBuiltinContexts integerContext;
					builtin: #arrays.
		self arraySortsFor: builder.
		self arrayOpsFor: builder.
		ArrayContext := builder context ].
	^ ArrayContext
]

{ #category : #defining }
LzBuiltinContexts class >> arrayFoldContext [
	^ LzContextBuilder new
		include: self arrayContext;
		include: self functionContext;
		op: 'âˆ€ s_:ğ•Š ',
			'fold(fn(s_, s_, s_), s_, Array1D(s_)) : s_';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ F_:fn(s__, s__, s__) ',
				'âˆ€ V_:s__ ',
				'âˆ€ A_:Array1D(s__) ',
				'fold(F_, V_, A_) â†’ ''A ensureArrayTerm. A inject: V into: F reducer: reducer'':nil';
		op: 'âˆ€ s_:ğ•Š ',
			'fold(fn(s_, s_, s_), s_, EmptyArray) : s_';
		rule: 'âˆ€ s__:ğ•Š âˆ€ f_:fn(s__, s__, s__) ',
				'âˆ€ v_:s__ âˆ€ a_:EmptyArray ',
				'fold(f_, v_, a_) â‡’ v_';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayIndexingContext [
	^ LzContextBuilder new
		include: self arrayContext;
		sort: 'â‹¯';
		op: 'â„•.nz â‹¯ â„•.nz : â‹¯';
		op: 'âˆ : â„•.nz';
		op: 'âˆ€ s_:ğ•Š ',
				'(Array1D(s_))[â„•.nz] : s_';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ A_:Array1D(s__) ',
				'âˆ€ i_:â„•.nz ',
				'A_[i_] â†’ ''A ensureArrayTerm. A index: i'':nil';
		op: 'âˆ€ s_:ğ•Š ',
				'(Array1D(s_))[â‹¯] : Array1D(s_)';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ A_:Array1D(s__) ',
				'âˆ€ i_:â„•.nz ',
				'A_[i_ â‹¯ âˆ] â†’ ''A ensureArrayTerm. A sliceToEndFrom: i by: 1'':nil';
		rule: 'âˆ€ s__:ğ•Š ',
				'âˆ€ A_:Array1D(s__) ',
				'âˆ€ i_:â„•.nz âˆ€ j_:â„•.nz ',
				'A_[i_ â‹¯ j_] â†’ ''A ensureArrayTerm. A slice: i to: j by: 1'':nil';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayMap2Context [
	^ LzContextBuilder new
		include: self arrayContext;
		include: self functionContext;
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š ',
			'(fn(from1_, from2_, to_))[Array(from1_), Array(from2_)] : Array(to_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_), Array(from2_, i_)] : Array(to_, i_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_, j_), Array(from2_, i_, j_)] : Array(to_, i_, j_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_, j_, k_), Array(from2_, i_, j_, k_)] : Array(to_, i_, j_, k_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• âˆ€ l_:â„• ',
			'(fn(from1_, from2_, to_))[Array(from1_, i_, j_, k_, l_), Array(from2_, i_, j_, k_, l_)] : Array(to_, i_, j_, k_, l_)';
		rule: 'âˆ€ from1__:ğ•Š âˆ€ from2__:ğ•Š âˆ€ to__:ğ•Š ',
				'âˆ€ F_:fn(from1__, from2__, to__) ',
				'âˆ€ A_:Array(from1__) ',
				'âˆ€ B_:Array(from2__) ',
				'F_[A_, B_] â†’ ''A ensureArrayTerm. B ensureArrayTerm. A with: B applyFn: F reducer: reducer'':nil';

		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š ',
			'(fn(from1_, from2_, to_))[EmptyArray, EmptyArray] : EmptyArray';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_), EmptyArray(i_)] : EmptyArray(i_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_, j_), EmptyArray(i_, j_)] : EmptyArray(i_, j_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_, j_, k_), EmptyArray(i_, j_, k_)] : EmptyArray(i_, j_, k_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• âˆ€ l_:â„• ',
			'(fn(from1_, from2_, to_))[EmptyArray(i_, j_, k_, l_), EmptyArray(i_, j_, k_, l_)] : EmptyArray(i_, j_, k_, l_)';
		rule: 'âˆ€ from1__:ğ•Š âˆ€ from2__:ğ•Š âˆ€ to__:ğ•Š ',
				'âˆ€ f_:fn(from1__, from2__, to__) ',
				'âˆ€ a_:EmptyArray ',
				'f_[a_, a_] â‡’ a_';
		context
]

{ #category : #defining }
LzBuiltinContexts class >> arrayMapContext [
	^ LzContextBuilder new
		include: self arrayContext;
		include: self functionContext;
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š ',
			'(fn(from_, to_))[Array(from_)] : Array(to_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• ',
			'(fn(from_, to_))[Array(from_, i_)] : Array(to_, i_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• ',
			'(fn(from_, to_))[Array(from_, i_, j_)] : Array(to_, i_, j_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• ',
			'(fn(from_, to_))[Array(from_, i_, j_, k_)] : Array(to_, i_, j_, k_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• âˆ€ l_:â„• ',
			'(fn(from_, to_))[Array(from_, i_, j_, k_, l_)] : Array(to_, i_, j_, k_, l_)';
		rule: 'âˆ€ from__:ğ•Š âˆ€ to__:ğ•Š âˆ€ F_:fn(from__, to__) ',
				'âˆ€ A_:Array(from__) ',
				'F_[A_] â†’ ''A ensureArrayTerm. A applyFn: F reducer: reducer'':nil';

		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š ',
			'(fn(from_, to_))[EmptyArray] : EmptyArray';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• ',
			'(fn(from_, to_))[EmptyArray(i_)] : EmptyArray(i_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• ',
			'(fn(from_, to_))[EmptyArray(i_, j_)] : EmptyArray(i_, j_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• ',
			'(fn(from_, to_))[EmptyArray(i_, j_, k_)] : EmptyArray(i_, j_, k_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š âˆ€ i_:â„• âˆ€ j_:â„• âˆ€ k_:â„• âˆ€ l_:â„• ',
			'(fn(from_, to_))[EmptyArray(i_, j_, k_, l_)] : EmptyArray(i_, j_, k_, l_)';
		rule: 'âˆ€ from__:ğ•Š âˆ€ to__:ğ•Š âˆ€ f_:fn(from__, to__) ',
				'âˆ€ a_:EmptyArray ',
				'f_[a_] â‡’ a_';
		context
]

{ #category : #private }
LzBuiltinContexts class >> arrayOpsFor: builder [
	builder
		op: 'âˆ€ s_:ğ•Š shape(Array(s_)) : Array(â„•)';
		rule: 'âˆ€ s__:ğ•Š âˆ€ A_:Array(s__) shape(A_) â†’ ''A shapeAsArrayTerm'':nil'.
]

{ #category : #private }
LzBuiltinContexts class >> arraySortsFor: builder [
	builder
		sort: 'Array(ğ•Š)';
		sort: 'Array1D(ğ•Š)';
		subsort: 'âˆ€ s_:ğ•Š ',
					'Array1D(s_) âŠ† Array(s_)';
		sort: 'Array2D(ğ•Š)';
		subsort: 'âˆ€ s_:ğ•Š ',
					'Array2D(s_) âŠ† Array(s_)';
		sort: 'Array3D(ğ•Š)';
		subsort: 'âˆ€ s_:ğ•Š ',
					'Array3D(s_) âŠ† Array(s_)';
		sort: 'Array4D(ğ•Š)';
		subsort: 'âˆ€ s_:ğ•Š ',
					'Array4D(s_) âŠ† Array(s_)';
		sort: 'Array(ğ•Š, â„•)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ i1_:â„• ',
					'Array(s_, i1_) âŠ† Array1D(s_)';
		sort: 'Array(ğ•Š, â„•, â„•)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ i1_:â„• âˆ€ i2_:â„• ',
					'Array(s_, i1_, i2_) âŠ† Array2D(s_)';
		sort: 'Array(ğ•Š, â„•, â„•, â„•)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ i1_:â„• âˆ€ i2_:â„• âˆ€ i3_:â„• ',
					'Array(s_, i1_, i2_, i3_) âŠ† Array3D(s_)';
		sort: 'Array(ğ•Š, â„•, â„•, â„•, â„•)';
		subsort: 'âˆ€ s_:ğ•Š âˆ€ i1_:â„• âˆ€ i2_:â„• âˆ€ i3_:â„• âˆ€ i4_:â„• ',
					'Array(s_, i1_, i2_, i3_, i4_) âŠ† Array3D(s_)';
		sort: 'EmptyArray';
		sort: 'EmptyArray1D';
		sort: 'EmptyArray2D';
		sort: 'EmptyArray3D';
		sort: 'EmptyArray4D';
		subsort: 'EmptyArray1D âŠ† EmptyArray';
		subsort: 'EmptyArray2D âŠ† EmptyArray';
		subsort: 'EmptyArray3D âŠ† EmptyArray';
		subsort: 'EmptyArray4D âŠ† EmptyArray';
		sort: 'EmptyArray(â„•)';
		subsort: 'âˆ€ i1_:â„• ',
					'EmptyArray(i1_) âŠ† EmptyArray1D';
		sort: 'EmptyArray(â„•, â„•)';
		subsort: 'âˆ€ i1_:â„• âˆ€ i2_:â„• ',
					'EmptyArray(i1_, i2_) âŠ† EmptyArray2D';
		subsort: 'âˆ€ i1_:â„• âˆ€ i2_:â„• ',
					'EmptyArray(i1_, i2_) âŠ† EmptyArray(i1_)';
		sort: 'EmptyArray(â„•, â„•, â„•)';
		subsort: 'âˆ€ i1_:â„• âˆ€ i2_:â„• âˆ€ i3_:â„• ',
					'EmptyArray(i1_, i2_, i3_) âŠ† EmptyArray3D';
		subsort: 'âˆ€ i1_:â„• âˆ€ i2_:â„• âˆ€ i3_:â„• ',
					'EmptyArray(i1_, i2_, i3_) âŠ† EmptyArray(i1_, i2_)';
		sort: 'EmptyArray(â„•, â„•, â„•, â„•)';
		subsort: 'âˆ€ i1_:â„• âˆ€ i2_:â„• âˆ€ i3_:â„• âˆ€ i4_:â„• ',
					'EmptyArray(i1_, i2_, i3_, i4_) âŠ† EmptyArray4D';
		subsort: 'âˆ€ i1_:â„• âˆ€ i2_:â„• âˆ€ i3_:â„• âˆ€ i4_:â„• ',
					'EmptyArray(i1_, i2_, i3_, i4_) âŠ† EmptyArray(i1_, i2_, i3_)'
]

{ #category : #defining }
LzBuiltinContexts class >> equalityContext [
	EqualityContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			op: 'âˆ€ s_:ğ•Š s_ == s_ : ğ”¹';
			axiom: 'âˆ€ s__:ğ•Š âˆ€ x_:s__ âˆ€ y_:s__ (x_ == y_) = (y_ == x_)';
			rule: 'âˆ€ s__:ğ•Š âˆ€ X_:s__ âˆ€ Y_:s__ X_ == Y_ â†’ ''X = Y'':LzBooleanTerm'.
		EqualityContext := builder context ].
	^ EqualityContext
]

{ #category : #defining }
LzBuiltinContexts class >> functionContext [
	^ LzContextBuilder new
		sort: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š ',
				'fn(from_, to_)';
		op: 'âˆ€ from_:ğ•Š âˆ€ to_:ğ•Š ',
				'(fn(from_, to_))[from_] : to_';
		sort: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š ',
				'fn(from1_, from2_, to_)';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š ',
				'(fn(from1_, from2_, to_))[from1_, from2_] : to_';
		op: 'âˆ€ from1_:ğ•Š âˆ€ from2_:ğ•Š âˆ€ to_:ğ•Š ',
				'(fn(from1_, from2_, to_))[from1_] : fn(from2_, to_)';
		rule: 'âˆ€ from1__:ğ•Š âˆ€ from2__:ğ•Š âˆ€ to__:ğ•Š ',
				'âˆ€ f_:fn(from1__, from2__, to__) ',
				'âˆ€ a_:from1__ âˆ€ b_:from2__ ',
				'(f_[a_])[b_] â‡’ f_[a_, b_]';
		context
]

{ #category : #private }
LzBuiltinContexts class >> integerAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤  x_ + y_ = y_ + x_';
		axiom: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤  âˆ€ z_:â„¤  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤  x_ Ã— y_ = y_ Ã— x_';
		axiom: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤  âˆ€ z_:â„¤  (x_ Ã— y_) Ã— z_ = x_ Ã— (y_ Ã— z_)';
		"distribution"
		axiom: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤  âˆ€ z_:â„¤  x_ Ã— (y_ + z_) = (x_ Ã— y_) + (x_ Ã— z_)'
]

{ #category : #defining }
LzBuiltinContexts class >> integerContext [
	IntegerContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers.
		self integerSortsFor: builder.
		self integerOpsFor: builder.
		self integerAxiomsFor: builder.
		self integerRulesFor: builder.
		IntegerContext := builder context ].
	^ IntegerContext
]

{ #category : #private }
LzBuiltinContexts class >> integerOpsFor: aContextBuilder [
	aContextBuilder
		"Predecessor and successor for natural numbers"
		op: 'succ(â„•) : â„•.nz';
		op: 'pred(â„•.nz) : â„•';
		"Arithmetic operators"
		op: 'â„¤ + â„¤ : â„¤';
		op: 'â„• + â„• : â„•';
		op: 'â„•.nz + â„•.nz : â„•.nz';
		op: 'â„•.nz + â„• : â„•.nz';
		op: 'â„• + â„•.nz : â„•.nz';
		op: 'â„¤ - â„¤ : â„¤';
		op: '-(â„¤) : â„¤';
		op: 'â„¤ Ã— â„¤ : â„¤';
		op: 'â„• Ã— â„• : â„•';
		op: 'â„•.nz Ã— â„•.nz : â„•.nz';
		op: 'â„¤.nz Ã— â„¤.nz : â„¤.nz';
		op: 'â„¤ div â„¤.nz : â„¤';
		op: 'â„• div â„•.nz : â„•';
		op: 'â„¤ rem â„¤.nz : â„¤';
		op: 'â„• rem â„•.nz : â„•';
		op: 'â„¤^(â„•.nz) : â„¤';
		op: 'â„•^(â„•.nz) : â„•';
		op: 'â„•.nz^(â„•.nz) : â„•.nz';
		op: 'â„¤.nz^(â„•.nz) : â„¤.nz';
		op: 'â„¤.nz^(zero) : â„•.nz';
		op: 'abs(â„¤) : â„•';
		op: 'abs(â„¤.nz) : â„•.nz';
		"Comparison operators"
		op: 'â„¤ < â„¤ : ğ”¹';
		op: 'â„¤ > â„¤ : ğ”¹';
		op: 'â„¤ â‰¤ â„¤ : ğ”¹';
		op: 'â„¤ â‰¥ â„¤ : ğ”¹'.
]

{ #category : #private }
LzBuiltinContexts class >> integerRulesFor: aContextBuilder [
	aContextBuilder
		"predecessor/successor rules"
		rule: 'âˆ€ x_:â„•.nz pred(x_) â†’ ''x - 1'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„• succ(x_) â†’ ''x + 1'':LzIntegerTerm';
		"addition rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ zero_:zero x_ + zero_ â‡’ x_';
		rule: 'âˆ€ x_:â„¤ âˆ€ zero_:zero zero_ + x_ â‡’ x_';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ + y_ â†’ ''x + y'':LzIntegerTerm';
		"subtraction rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ zero_:zero x_ - zero_ â‡’ x_';
		rule: 'âˆ€ x_:â„¤ âˆ€ zero_:zero zero_ - x_ â‡’ -(x_)';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ - y_ â†’ ''x - y'':LzIntegerTerm';
		rule: 'âˆ€ zero_:zero -(zero_) â‡’ 0';
		rule: 'âˆ€ x_:â„¤ -(x_) â†’ ''x negated'':LzIntegerTerm';
		"multiplication rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ zero_:zero x_ Ã— zero_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ âˆ€ zero_:zero zero_ Ã— x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ 1 Ã— x_ â‡’ x_';
		rule: 'âˆ€ x_:â„¤ x_ Ã— 1 â‡’ x_';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ Ã— y_ â†’ ''x * y'':LzIntegerTerm';
		"division rules"
		rule: 'âˆ€ x_:â„¤.nz âˆ€ zero_:zero zero_ div x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ x_ div 1 â‡’ x_';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤.nz x_ div y_ â†’ ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„¤.nz âˆ€ zero_:zero zero_ rem x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ x_ rem 1 â‡’ 0';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤.nz x_ rem y_ â†’ ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"exponentiation rules"
		rule: 'âˆ€ x_:â„¤.nz âˆ€ zero_:zero x_^(zero_) â‡’ 1';
		rule: 'âˆ€ x_:â„•.nz âˆ€ zero_:zero zero_^(x_) â‡’ 0';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„•.nz x_^(y_) â†’ ''x raisedTo: y'':LzIntegerTerm';
		"abs rules"
		rule: 'âˆ€ x_:â„• abs(x_) â‡’ x_';
		rule: 'âˆ€ x_:â„¤ abs(x_) â‡’ -(x_) | x_ < 0';
		rule: 'âˆ€ x_:â„¤ abs(x_) â†’ ''x abs'':LzIntegerTerm';
		"comparison rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ < y_ â†’ ''x < y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ > y_ â†’ ''x > y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ â‰¤ y_ â†’ ''x <= y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ â‰¥ y_ â†’ ''x >= y'':LzBooleanTerm'.
]

{ #category : #private }
LzBuiltinContexts class >> integerSortsFor: aContextBuilder [
	aContextBuilder
		"Natural numbers"
		sort: 'â„•';
		sort: 'â„•.nz';
		sort: 'zero';
		subsort: 'zero âŠ† â„•';
		subsort: 'â„•.nz âŠ† â„•';
		sort: 'one';
		subsort: 'one âŠ† â„•.nz';
		"Integers"
		sort: 'â„¤';
		sort: 'â„¤.nz';
		subsort: 'â„• âŠ† â„¤';
		subsort: 'â„¤.nz âŠ† â„¤';
		subsort: 'â„•.nz âŠ† â„¤.nz'.
]

{ #category : #private }
LzBuiltinContexts class >> numberArrayOpsAndRulesForBuilder: builder sort: s [
	builder
		op: '+ : fn(',s,', ',s,', ',s,')';
		rule: 'âˆ€ x_:',s,' âˆ€ y_:',s,' +[x_, y_] â‡’ x_ + y_';
		op: 'âˆ€ i_:â„•.nz (Array(',s,', i_)) + (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'âˆ€ i__:â„•.nz âˆ€ a_:Array(',s,', i__) âˆ€ b_:Array(',s,', i__) ',
				'a_ + b_ â‡’ +[a_, b_]';
		op: 'âˆ€ i_:zero (EmptyArray(i_)) + (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'âˆ€ i__:â„• âˆ€ a_:EmptyArray(i__) âˆ€ b_:EmptyArray(i__) a_ + b_ â‡’ a_';

		op: 'Î£(Array1D(',s,')) : ',s,'';
		op: 'âˆ€ i_:â„•.nz Î£(Array(',s,', i_)) : ',s,'';
		rule: 'âˆ€ a_:Array1D(',s,')',
				'Î£(a_) â‡’ fold(+, 0, a_)';

		op: '- : fn(',s,', ',s,', ',s,')';
		rule: 'âˆ€ x_:',s,' âˆ€ y_:',s,' -[x_, y_] â‡’ x_ - y_';
		op: 'âˆ€ i_:â„•.nz (Array(',s,', i_)) - (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'âˆ€ i__:â„•.nz âˆ€ a_:Array(',s,', i__) âˆ€ b_:Array(',s,', i__) ',
				'a_ - b_ â‡’ -[a_, b_]';
		op: 'âˆ€ i_:zero (EmptyArray(i_)) - (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'âˆ€ i__:â„• âˆ€ a_:EmptyArray(i__) âˆ€ b_:EmptyArray(i__) a_ - b_ â‡’ a_';

		op: 'Ã— : fn(',s,', ',s,', ',s,')';
		rule: 'âˆ€ x_:',s,' âˆ€ y_:',s,' Ã—[x_, y_] â‡’ x_ Ã— y_';
		op: 'âˆ€ i_:â„•.nz (Array(',s,', i_)) Ã— (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'âˆ€ i__:â„•.nz âˆ€ a_:Array(',s,', i__) âˆ€ b_:Array(',s,', i__) ',
				'a_ Ã— b_ â‡’ Ã—[a_, b_]';
		op: 'âˆ€ i_:zero (EmptyArray(i_)) Ã— (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'âˆ€ i__:â„• âˆ€ a_:EmptyArray(i__) âˆ€ b_:EmptyArray(i__) a_ Ã— b_ â‡’ a_';

		op: 'Î (Array1D(',s,')) : ',s,'';
		op: 'âˆ€ i_:â„•.nz Î (Array(',s,', i_)) : ',s,'';
		rule: 'âˆ€ a_:Array1D(',s,')',
				'Î (a_) â‡’ fold(Ã—, 1, a_)';

		op: 'Ã· : fn(',s,', ',s,'.nz, ',s,')';
		rule: 'âˆ€ x_:',s,' âˆ€ y_:',s,'.nz Ã·[x_, y_] â‡’ x_ Ã· y_';
		op: 'âˆ€ i_:â„•.nz (Array(',s,', i_)) Ã· (Array(',s,', i_)) : Array(',s,', i_)';
		rule: 'âˆ€ i__:â„•.nz âˆ€ a_:Array(',s,', i__) âˆ€ b_:Array(',s,', i__) ',
				'a_ Ã· b_ â‡’ Ã·[a_, b_]';
		op: 'âˆ€ i_:zero (EmptyArray(i_)) Ã· (EmptyArray(i_)) : EmptyArray(i_)';
		rule: 'âˆ€ i__:â„• âˆ€ a_:EmptyArray(i__) âˆ€ b_:EmptyArray(i__) a_ Ã· b_ â‡’ a_'
]

{ #category : #defining }
LzBuiltinContexts class >> rationalNumberArrayContext [
	| builder |
	builder := LzContextBuilder new
		include: self arrayMap2Context;
		include: self arrayFoldContext;
		include: self rationalNumberContext.
	self numberArrayOpsAndRulesForBuilder: builder sort: 'â„š'.
	^ builder context
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'âˆ€ x_:â„š âˆ€ y_:â„š  x_ + y_ = y_ + x_';
		axiom: 'âˆ€ x_:â„š âˆ€ y_:â„š  âˆ€ z_:â„š  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: 'âˆ€ x_:â„š âˆ€ y_:â„š  x_ Ã— y_ = y_ Ã— x_';
		axiom: 'âˆ€ x_:â„š âˆ€ y_:â„š  âˆ€ z_:â„š  (x_ Ã— y_) Ã— z_ = x_ Ã— (y_ Ã— z_)';
		"distribution"
		axiom: 'âˆ€ x_:â„š âˆ€ y_:â„š  âˆ€ z_:â„š  x_ Ã— (y_ + z_) = (x_ Ã— y_) + (x_ Ã— z_)'
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberBuiltinRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ + y_ â†’ ''x + y'':LzRationalNumberTerm';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ + y_ â†’ ''x + y'':LzIntegerTerm';
		"Subtraction rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ - y_ â†’ ''x - y'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ - y_ â†’ ''x - y'':LzRationalNumberTerm';
		"Negation rules"
		rule: 'âˆ€ x_:â„¤ -(x_) â†’ ''x negated'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„š -(x_) â†’ ''x negated'':LzRationalNumberTerm';
		"Multiplication rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤ x_ Ã— y_ â†’ ''x * y'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ Ã— y_ â†’ ''x * y'':LzRationalNumberTerm';
		"Division rules"
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š.nz x_ Ã· y_ â†’ ''x / y'':LzRationalNumberTerm';
		"Integer div and rem rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤.nz x_ div y_ â†’ ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„¤.nz x_ rem y_ â†’ ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"Exponentiation rules"
		rule: 'âˆ€ x_:â„¤ âˆ€ y_:â„•.nz x_^(y_) â†’ ''x raisedTo: y'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„š.nz âˆ€ y_:â„¤.nz x_^(y_) â†’ ''x raisedTo: y'':LzRationalNumberTerm';
		"Abs rules"
		rule: 'âˆ€ x_:â„¤ abs(x_) â†’ ''x abs'':LzIntegerTerm';
		rule: 'âˆ€ x_:â„š abs(x_) â†’ ''x abs'':LzRationalNumberTerm'.
]

{ #category : #defining }
LzBuiltinContexts class >> rationalNumberContext [
	RationalNumberContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers;
			builtin: #rationalNumbers.
		self integerSortsFor: builder.
		self rationalNumberSortsFor: builder.
		self integerOpsFor: builder.
		self rationalNumberOpsFor: builder.
		"No integerAxioms, because they would be redundant."
		self rationalNumberAxiomsFor:  builder.
		"No integerRules, the few that are required are repeated in rationalRules."
		self rationalNumberRulesFor: builder.
		RationalNumberContext := builder context ].
	^ RationalNumberContext
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberOpsFor: aContextBuilder [
	aContextBuilder
		"Arithmetic operators"
		op: 'â„š + â„š : â„š';
		op: 'â„š.p + â„š.p : â„š.p';
		op: 'â„š.nn + â„š.nn : â„š.nn';
		op: 'â„š - â„š : â„š';
		op: '-(â„š) : â„š';
		op: 'â„š Ã— â„š : â„š';
		op: 'â„š.p Ã— â„š.p : â„š.p';
		op: 'â„š.nn Ã— â„š.nn : â„š.nn';
		op: 'â„š.nz Ã— â„š.nz : â„š.nz';
		op: 'â„š Ã· â„š.nz : â„š';
		op: 'â„š.nz Ã· â„š.nz : â„š.nz';
		op: 'â„š.nn Ã· â„š.p : â„š.nn';
		op: 'â„š.p Ã· â„š.p : â„š.p';
		op: 'â„š.nz^(â„¤.nz) : â„š.nz';
		op: 'â„š.p^(â„¤.nz) : â„š.p';
		op: 'â„š.nz^(zero) : â„•.nz';
		op: 'abs(â„š) : â„š.nn';
		op: 'abs(â„š.nz) : â„š.p';
		"Comparison operators"
		op: 'â„š < â„š : ğ”¹';
		op: 'â„š > â„š : ğ”¹';
		op: 'â„š â‰¤ â„š : ğ”¹';
		op: 'â„š â‰¥ â„š : ğ”¹'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: 'âˆ€ x_:â„š âˆ€ z_:zero x_ + z_ â‡’ x_';
		rule: 'âˆ€ x_:â„š âˆ€ z_:zero z_ + x_ â‡’ x_';
		"Subtraction rules"
		rule: 'âˆ€ x_:â„š âˆ€ z_:zero x_ - z_ â‡’ x_';
		rule: 'âˆ€ x_:â„š âˆ€ z_:zero z_ - x_ â‡’ -(x_)';
		"Negation rules"
		rule: 'âˆ€ z_:zero -(z_) â‡’ 0';
		"Multiplication rules"
		rule: 'âˆ€ x_:â„š âˆ€ z_:zero x_ Ã— z_ â‡’ 0';
		rule: 'âˆ€ x_:â„š âˆ€ z_:zero z_ Ã— x_ â‡’ 0';
		rule: 'âˆ€ x_:â„š 1 Ã— x_ â‡’ x_';
		rule: 'âˆ€ x_:â„š x_ Ã— 1 â‡’ x_';
		"Division rules"
		rule: 'âˆ€ x_:â„š.nz âˆ€ z_:zero z_ Ã· x_ â‡’ 0';
		rule: 'âˆ€ x_:â„š x_ Ã· 1 â‡’ x_';
		"Integer div and rem rules"
		rule: 'âˆ€ x_:â„¤.nz âˆ€ z_:zero z_ div x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ x_ div 1 â‡’ x_';
		rule: 'âˆ€ x_:â„¤.nz âˆ€ z_:zero z_ rem x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ x_ rem 1 â‡’ 0';
		"Exponentiation rules"
		rule: 'âˆ€ x_:â„š.nz âˆ€ z_:zero x_^(z_) â‡’ 1';
		rule: 'âˆ€ x_:â„•.nz âˆ€ z_:zero z_^(x_) â‡’ 0';
		"Abs rules"
		rule: 'âˆ€ x_:â„š.nn abs(x_) â‡’ x_';
		rule: 'âˆ€ x_:â„š abs(x_) â‡’ -(x_) | x_ < 0';
		"Comparison rules"
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ < y_ â†’ ''x < y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ > y_ â†’ ''x > y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ â‰¤ y_ â†’ ''x <= y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„š âˆ€ y_:â„š x_ â‰¥ y_ â†’ ''x >= y'':LzBooleanTerm'.
	self rationalNumberBuiltinRulesFor: aContextBuilder
]

{ #category : #private }
LzBuiltinContexts class >> rationalNumberSortsFor: aContextBuilder [
	aContextBuilder
		"Rational numbers"
		sort: 'â„š';
		sort: 'â„š.nn';
		sort: 'â„š.nz';
		sort: 'â„š.p';
		subsort: 'â„š.nz âŠ† â„š';
		subsort: 'â„š.p âŠ† â„š.nz';
		subsort: 'â„š.nn âŠ† â„š';
		subsort: 'â„š.p âŠ† â„š.nn';
		subsort: 'â„• âŠ† â„š.nn';
		subsort: 'â„•.nz âŠ† â„š.p';
		subsort: 'â„¤ âŠ† â„š';
		subsort: 'â„¤.nz âŠ† â„š.nz'.
]

{ #category : #defining }
LzBuiltinContexts class >> realNumberArrayContext [
	| builder |
	builder := LzContextBuilder new
		include: self arrayMap2Context;
		include: self arrayFoldContext;
		include: self realNumberContext.
	self numberArrayOpsAndRulesForBuilder: builder sort: 'â„'.
	^ builder context
]

{ #category : #private }
LzBuiltinContexts class >> realNumberAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'âˆ€ x_:â„ âˆ€ y_:â„  x_ + y_ = y_ + x_';
		axiom: 'âˆ€ x_:â„ âˆ€ y_:â„  âˆ€ z_:â„  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: 'âˆ€ x_:â„ âˆ€ y_:â„  x_ Ã— y_ = y_ Ã— x_';
		axiom: 'âˆ€ x_:â„ âˆ€ y_:â„  âˆ€ z_:â„  (x_ Ã— y_) Ã— z_ = x_ Ã— (y_ Ã— z_)';
		"distribution"
		axiom: 'âˆ€ x_:â„ âˆ€ y_:â„  âˆ€ z_:â„  x_ Ã— (y_ + z_) = (x_ Ã— y_) + (x_ Ã— z_)'.
]

{ #category : #defining }
LzBuiltinContexts class >> realNumberContext [
	RealNumberContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers;
			builtin: #rationalNumbers.
		self integerSortsFor: builder.
		self rationalNumberSortsFor: builder.
		self realNumberSortsFor: builder.
		self integerOpsFor: builder.
		self rationalNumberOpsFor: builder.
		self realNumberOpsFor: builder.
		"No rationalNumberAxioms, because they would be redundant."
		self realNumberAxiomsFor: builder.
		"No rationalNumberRules, the few that are required are repeated in realNumberRules."
		self realNumberRulesFor: builder.
		RealNumberContext := builder context ].
	^ RealNumberContext
]

{ #category : #private }
LzBuiltinContexts class >> realNumberOpsFor: builder [
	builder
		"Arithmetic operators"
		op: 'â„ + â„ : â„';
		op: 'â„.p + â„.p : â„.p';
		op: 'â„.nn + â„.nn : â„.nn';
		op: 'â„ - â„ : â„';
		op: '-(â„) : â„';
		op: 'â„ Ã— â„ : â„';
		op: 'â„.p Ã— â„.p : â„.p';
		op: 'â„.nn Ã— â„.nn : â„.nn';
		op: 'â„ Ã· â„.nz : â„';
		op: 'â„.nz Ã· â„.nz : â„.nz';
		op: 'â„.p Ã· â„.p : â„.p';
		op: 'â„.nn Ã· â„.p : â„.nn';
		op: 'â„.nz^(zero) : â„•.nz';
		op: 'â„.p^(â„.nz) : â„.p';
		op: 'â„.nz^(â„¤.nz) : â„.nz';
		op: 'â„^(â„•.nz) : â„';
		"Various functions"
		op: 'abs(â„) : â„.nn';
		op: 'abs(â„.nz) : â„.p';
		op: 'âˆš(â„.nn) : â„.nn';
		op: 'âˆš(â„.p) : â„.p';
		"Comparison operators"
		op: #'â„ < â„ : ğ”¹';
		op: #'â„ > â„ : ğ”¹';
		op: #'â„ â‰¤ â„ : ğ”¹';
		op: #'â„ â‰¥ â„ : ğ”¹'.
]

{ #category : #private }
LzBuiltinContexts class >> realNumberRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: 'âˆ€ x_:â„ âˆ€ zero_:zero x_ + zero_ â‡’ x_';
		rule: 'âˆ€ x_:â„ âˆ€ zero_:zero zero_ + x_ â‡’ x_';
		"Subtraction rules"
		rule: 'âˆ€ x_:â„ âˆ€ zero_:zero x_ - zero_ â‡’ x_';
		rule: 'âˆ€ x_:â„ âˆ€ zero_:zero zero_ - x_ â‡’ -(x_)';
		"Negation rules"
		rule: 'âˆ€ zero_:zero -(zero_) â‡’ 0';
		"Multiplication rules"
		rule: 'âˆ€ x_:â„ âˆ€ zero_:zero x_ Ã— zero_ â‡’ 0';
		rule: 'âˆ€ x_:â„ âˆ€ zero_:zero zero_ Ã— x_ â‡’ 0';
		rule: 'âˆ€ x_:â„ 1 Ã— x_ â‡’ x_';
		rule: 'âˆ€ x_:â„ x_ Ã— 1 â‡’ x_';
		"Division rules"
		rule: 'âˆ€ x_:â„.nz âˆ€ zero_:zero zero_ Ã· x_ â‡’ 0';
		rule: 'âˆ€ x_:â„ x_ Ã· 1 â‡’ x_';
		"Integer div and rem rules"
		rule: 'âˆ€ x_:â„¤.nz âˆ€ z_:zero z_ div x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ x_ div 1 â‡’ x_';
		rule: 'âˆ€ x_:â„¤.nz âˆ€ z_:zero z_ rem x_ â‡’ 0';
		rule: 'âˆ€ x_:â„¤ x_ rem 1 â‡’ 0';
		"Exponentiation rules"
		rule: 'âˆ€ x_:â„.nz âˆ€ zero_:zero x_^(zero_) â‡’ 1';
		rule: 'âˆ€ x_:â„•.nz âˆ€ z_:zero z_^(x_) â‡’ 0';
		"Abs rules"
		rule: 'âˆ€ x_:â„.nn abs(x_) â‡’ x_';
		rule: 'âˆ€ x_:â„ abs(x_) â‡’ -(x_) | x_ < 0';
		"Comparison rules"
		rule: 'âˆ€ x_:â„ âˆ€ y_:â„ x_ < y_ â†’ ''x < y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„ âˆ€ y_:â„ x_ > y_ â†’ ''x > y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„ âˆ€ y_:â„ x_ â‰¤ y_ â†’ ''x <= y'':LzBooleanTerm';
		rule: 'âˆ€ x_:â„ âˆ€ y_:â„ x_ â‰¥ y_ â†’ ''x >= y'':LzBooleanTerm'.
	self rationalNumberBuiltinRulesFor: aContextBuilder
]

{ #category : #private }
LzBuiltinContexts class >> realNumberSortsFor: builder [
	builder
		sort: 'â„';
		sort: 'â„.nz';
		sort: 'â„.nn';
		sort: 'â„.p';
		subsort: 'â„š âŠ† â„';
		subsort: 'â„.nz âŠ† â„';
		subsort: 'â„š.nz âŠ† â„.nz';
		subsort: 'â„.p âŠ† â„.nz';
		subsort: 'â„š.p âŠ† â„.p';
		subsort: 'â„.nn âŠ† â„';
		subsort: 'â„.p âŠ† â„.nn';
		subsort: 'â„š.nn âŠ† â„.nn'.
]

{ #category : #resetting }
LzBuiltinContexts class >> reset [
	TruthContext := nil.
	EqualityContext := nil.
	IntegerContext := nil.
	RationalNumberContext := nil.
	RealNumberContext := nil.
	StringContext := nil.
	ArrayContext := nil.
]

{ #category : #defining }
LzBuiltinContexts class >> sortContext [
	^ LzSortHierarchyRoot uniqueInstance sortContext
]

{ #category : #defining }
LzBuiltinContexts class >> stringContext [
	StringContext ifNil: [
		StringContext :=
			LzContextBuilder new
				builtin: #strings;
				sort: 'string';
				op: 'string + string : string';
				rule: 'âˆ€ a_:string âˆ€ b_:string a_ + b_ â†’ ''a, b'':LzStringTerm';
				context ].
	^ StringContext
]

{ #category : #defining }
LzBuiltinContexts class >> truthContext [
	TruthContext ifNil: [
		TruthContext :=
			LzContextBuilder new
				sort: 'ğ”¹';
				op: 'âŠ¤ : ğ”¹';
				op: 'âŠ¥ : ğ”¹';
				context ].
	^ TruthContext
]
