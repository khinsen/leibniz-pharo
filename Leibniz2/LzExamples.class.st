Class {
	#name : #LzExamples,
	#superclass : #Object,
	#traits : 'TGtExampleAssertable',
	#classTraits : 'TGtExampleAssertable classTrait',
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #example }
LzExamples >> arrayOfIntegerTerms [
	<gtExample>
	| context |
	context := LzBuiltinContexts arrayContext.
"	self should: [
		context term: '' ]
		raise: Error."
	^ {
		{ '{[ 1, 2, 3 ]}'. '{[ 1, 2, 3 ]}' }.
		{ '{[[0], [1], [2]]}'. '{[[0], [1], [2]]}' }.
		{ '{[1 + 2, 2 + 3]}'. '{[3, 5]}' }.
		{ 'shape({[1, 2, 3]})'. '{[3]}' }.
	} collect: [ :each |
		| term reducedTerm shape |
		term := context term: each first.
		reducedTerm := context term: each second.
		self assert: (context reduce: term) equals: reducedTerm.
		term ]
]

{ #category : #example }
LzExamples >> bagContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listContext;
		include: LzBuiltinContexts integerContext;
		sort: 'collection';
		sort: 'bag(ð•Š, â„•)';
		subsort: 'âˆ€ s_:ð•Š âˆ€ n_:â„• list(s_, n_) âŠ† bag(s_, n_)';
		subsort: 'âˆ€ s_:ð•Š âˆ€ n_:â„• bag(s_, n_) âŠ† collection';
		subsort: 'âˆ… âŠ† collection';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• âˆ€ m_:â„• (bag(s_, n_)) ** (bag(s_, m_)) : bag(s_, n_ + m_)';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• (bag(s_, n_)) ** s_ : bag(s_, n_ + 1)';
		op: 'âˆ€ s_:ð•Š âˆ… ** s_ : bag(s_, 1)';
		op: 'size(collection) : â„•';
		context
]

{ #category : #example }
LzExamples >> bagRules [
	<gtExample>
	| context |
	context := self bagContext.
	^ {
		'âˆ… ++ 1 â‡’ âˆ…'.
		'size(âˆ…) â‡’ 0'.
	} collect: [ :each |
		| rule |
		rule := context rule: each.
		self assert: rule asLeibnizSyntaxString equals: each.
		rule ]
]

{ #category : #example }
LzExamples >> bagSignature [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self bagSortGraph;
		include: self listSignature;
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• âˆ€ m_:â„• (bag(s_, n_)) ** (bag(s_, m_)) : bag(s_, n_ + m_)';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• (bag(s_, n_)) ** s_ : bag(s_, n_ + 1)';
		op: 'âˆ€ s_:ð•Š âˆ… ** s_ : bag(s_, 1)';
		signature
]

{ #category : #example }
LzExamples >> bagSortContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listSortContext;
		op: 'collection : ð•Š';
		op: 'bag(ð•Š, â„•) : ð•Š';
		op: 'â„• : ð•Š';
		axiom: 'âˆ€ s_:ð•Š âˆ€ n_:â„• list(s_, n_) âŠ† bag(s_, n_)';
		axiom: 'âˆ€ s_:ð•Š âˆ€ n_:â„• bag(s_, n_) âŠ† collection';
		axiom: 'âˆ… âŠ† collection';
		context
]

{ #category : #example }
LzExamples >> bagSortGraph [
	<gtExample>
	^ LzSortGraphBuilder new
		sortContext: self bagSortContext;
		sortGraph
]

{ #category : #example }
LzExamples >> booleanUnifications [
	<gtExample>
	| c |
	c := LzExampleContexts booleanContext.
	^ {
		{'âŠ¤'. 'âˆ€ X_:ð”¹ X_'. '(X_=âŠ¤)'}.
		{'âˆ€ X_:ð”¹ Â¬(X_)'. 'Â¬(âŠ¤)'. '(X_=âŠ¤)'}.
		{'âˆ€ X_:ð”¹ X_'. 'Â¬(âŠ¤)'. '(X_=Â¬(âŠ¤))'}.
		{'âŠ¤ âŠ» âŠ¥ âŠ» âŠ¤ âŠ» Â¬(âŠ¤)'. 'âˆ€ X_:ð”¹ âˆ€ Y_:ð”¹ (âŠ¤ âŠ» âŠ¥ âŠ» X_ âŠ» Y_)'. '(X_=âŠ¤, Y_=Â¬(âŠ¤))'}.
		{'âˆ€ X_:ð”¹ (âŠ¥ âŠ» X_ âŠ» âŠ¤ âŠ» Â¬(âŠ¤))'. 'âˆ€ X_:ð”¹ âˆ€ Y_:ð”¹ (âŠ¥ âŠ» âŠ¤ âŠ» X_ âŠ» Y_)'. '(X_=âŠ¤, Y_=Â¬(âŠ¤))'}.
		{'âˆ€ X_:ð”¹ (X_ âŠ» Â¬(X_))'. 'âˆ€ X_:ð”¹ (âŠ¥ âŠ» Â¬(X_))'. '(X_=âŠ¥)'}.
		{'âˆ€ X_:ð”¹ âˆ€ Y_:ð”¹ (X_ âŠ» Â¬(Y_))'. 'âˆ€ Y_:ð”¹ (âŠ¥ âŠ» Â¬(Y_))'. '(Y_, X_=âŠ¥)'}.
		{'âˆ€ X_:ð”¹ (âŠ¥ âŠ» Â¬(X_))'. 'âˆ€ Y_:ð”¹ (âŠ¥ âŠ» Â¬(Y_))'. '(X_=Y_)'}.
		{'âŠ¤'. 'âŠ¥'.  '(failure #nonUnifiableTerms: âŠ¥, âŠ¤)' }.
		{'âˆ€ foo_:ð”¹ Â¬(foo_)'. 'âˆ€ bar_:ð”¹ Â¬(bar_)'. '(bar_=foo_)'}
	} collect: [ :each |
		| unification string |
		unification := (c pattern: each first) unify: (c pattern: each  second).
		string := unification printString.
		self assert: (string allButFirst: (string findString: '(') - 1) equals: each third.
		unification ]
]

{ #category : #example }
LzExamples >> equalityTerms [
	<gtExample>
	| context |
	context := self listPlusIntegerContext.
	self should: [
		context term: '1 == âˆ…' ]
		raise: Error.
	^ {
		{ '1 == 1'. 'âŠ¤'}.
		{ '1 == 2'. 'âŠ¥'}.
		{ '(âˆ… ++ 1) == (âˆ… ++ 1)'. 'âŠ¤'}.
		{'(âˆ… ++ 1) == (âˆ… ++ 2)'. 'âŠ¥'}
	} collect: [ :each |
		| term rewrittenTerm expected |
		term := context term: each first.
		expected := context term: each second.
		rewrittenTerm := context reduce: term.
		self assert: rewrittenTerm equals: expected.
		{ term. rewrittenTerm } ]
]

{ #category : #example }
LzExamples >> integerArithmetic [
	<gtExample>
	| context |
	context := LzBuiltinContexts integerContext.
	^ {
		{ '-(2)'. '-2' }.
		{ '2 + 2'. '4'}.
		{ '2 - 2'. '0'}.
		{ '3 Ã— 2'. '6'}.
		{ '3 div 2'. '1'}.		
		{ '3 rem 2'. '1'}.
		{ '3^(2)'. '9'}.
		{ '3^(0)'. '1'}.
		{ '0^(2)'. '0'}.
		{ '2 < 3'. 'âŠ¤'}.
		{ '2 > 3'. 'âŠ¥'}.
	}
	collect: [ :each |
		| term result |
		term := context term: each first.
		result := context reduce: term.
		self assert: result equals: (context term: each second).
		{ term. result } ]
]

{ #category : #example }
LzExamples >> integerTerms [
	<gtExample>
	| context |
	context := LzBuiltinContexts integerContext.
	^ {
		{ '0'. 'zero'. }.
		{ '1'. 'â„•.nz' }.
		{ '-1'. 'â„¤.nz' }.
		{ '-1 + 1'. 'â„¤' }.
		{ '1 + 1'. 'â„•.nz' }.
	}
	collect: [ :each |
		| term |
		term := context term: each first.
		self assert: term sort asLeibnizSyntaxString equals: each second.
		term  ]
]

{ #category : #example }
LzExamples >> listContext [
	<gtExample>
	^ LzContextBuilder new
		includeSortContext: LzBuiltinContexts integerContext;
		sort: 'element';
		sort: 'element.special';
		sort: 'âˆ…';
		sort: 'list(ð•Š, â„•)';
		subsort: 'element.special âŠ† element';		
		op: 'âˆ… : âˆ…';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• âˆ€ m_:â„• ',
				'(list(s_, n_)) ++ (list(s_, m_)) : list(s_, n_ + m_)';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• ',
				'(list(s_, n_)) ++ s_ : list(s_, n_ + 1)';
		op: 'âˆ€ s_:ð•Š ',
				'âˆ… ++ s_ : list(s_, 1)';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„•.nz ',
				'first(list(s_, n_)) : s_';
		op: 'anElement : element';
		op: 'aSpecialElement : element.special';
		rule: 'âˆ€ s__:ð•Š âˆ€ e_:s__ first(âˆ… ++ e_) â‡’ e_';
		context
]

{ #category : #example }
LzExamples >> listOfIntegerTerms [
	<gtExample>
	| context |
	context := self listPlusIntegerContext.
	^ {
		'âˆ…'.
		'âˆ… ++ 1'.
		'âˆ… ++ 1 ++ 2'.
		'first(âˆ… ++ 1)'.
	}
	collect: [ :each |
		 context term: each ]
]

{ #category : #example }
LzExamples >> listPlusIntegerContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listContext;
		include: LzBuiltinContexts integerContext;
		include: LzBuiltinContexts equalityContext;
		context
]

{ #category : #example }
LzExamples >> listSignature [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self listSortGraph;
		op: 'âˆ… : âˆ…';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• âˆ€ m_:â„• ',
				'(list(s_, n_)) ++ (list(s_, m_)) : list(s_, n_ + m_)';
		op: 'âˆ€ s_:ð•Š âˆ€ n_:â„• ',
				'(list(s_, n_)) ++ s_ : list(s_, n_ + 1)';
		op: 'âˆ€ s_:ð•Š ',
				'âˆ… ++ s_ : list(s_, 1)';
		op: 'anElement : element';
		signature
]

{ #category : #example }
LzExamples >> listSortContext [
	<gtExample>
	^ (LzContextBuilder new
		include: LzBuiltinContexts sortContext;
		include: LzBuiltinContexts integerContext;
		op: 'element : ð•Š';
		op: 'element.special : ð•Š';
		op: 'âˆ… : ð•Š';
		op: 'list(ð•Š, â„•) : ð•Š';
		axiom: 'element.special âŠ† element')
		context.
]

{ #category : #example }
LzExamples >> listSortGraph [
	<gtExample>
	^ LzSortGraphBuilder new
		sortContext: self listSortContext;
		sortGraph
]

{ #category : #example }
LzExamples >> listTermRewrites [
	<gtExample>
	| context |
	context := self listPlusIntegerContext.
	^ {
		'first(âˆ… ++ 1)'.
	}
	collect: [ :each |
		| term rewrittenTerm rule |
		term := context term: each.
		rewrittenTerm := context reduce: term.
		{ term. rewrittenTerm } ]
]

{ #category : #example }
LzExamples >> listTerms [
	<gtExample>
	| context |
	context := self listContext.
	^ {
		{ 'âˆ…'. 'âˆ…' }.
		{ 'âˆ… ++ anElement'. 'list(element, 1)' }.
		{ 'âˆ… ++ aSpecialElement'. 'list(element.special, 1)' }.
		{ 'âˆ… ++ anElement ++ aSpecialElement'. 'list(element, 2)' }.
		{ 'âˆ… ++ aSpecialElement ++ anElement'. 'list(element, 2)' }.
		{ 'first(âˆ… ++ anElement)'. 'element' }.
		{ 'first(âˆ… ++ aSpecialElement)'. 'element.special'}.
	}
	collect: [ :each |
		| term sort |
		 term := context term: each first.
		 sort := context sort: each second.
		 self assert: term sort equals: sort.
		 term ]
]

{ #category : #example }
LzExamples >> rationalArithmetic [
	<gtExample>
	| context |
	context := LzBuiltinContexts rationalNumberContext.
	^ {
		{ '-(2/3)'. '-2/3' }.
		{ '1/3 + 2/3'. '1'}.
		{ '2/3 - 2/3'. '0'}.
		{ '1/3 Ã— 2/5'. '2/15'}.
		{ '3 Ã· 2'. '3/2'}.
		{ '3/2^(2)'. '9/4'}.
		{ '3/2^(0)'. '1'}.
		{ '2/5 < 3/5'. 'âŠ¤'}.
		{ '2/5 > 3/5'. 'âŠ¥'}.
	}
	collect: [ :each |
		| term result |
		term := context term: each first.
		result := context reduce: term.
		self assert: result equals: (context term: each second).
		{ term. result } ]
]

{ #category : #example }
LzExamples >> rationalNumberTerms [
	<gtExample>
	| context |
	context := LzBuiltinContexts rationalNumberContext.
	^ {
		{ '0'. 'zero'. }.
		{ '1'. 'â„•.nz' }.
		{ '-1'. 'â„¤.nz' }.
		{ '-1 + 1'. 'â„¤' }.
		{ '1 + 1'. 'â„•.nz' }.
		{ '1/3'. 'â„š.p' }.
		{ '-1/3'. 'â„š.nz' }.
		{ '-1/3 + 1/3'. 'â„š' }.
		{ '1/3 + 1/3'. 'â„š.p' }.
	}
	collect: [ :each |
		| term |
		term := context term: each first.
		self assert: term sort asLeibnizSyntaxString equals: each second.
		term  ]
]

{ #category : #accessing }
LzExamples >> signatureWithSubsorts [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self sortGraphWithSubsorts;
		op: 'anA : A';
		op: 'aB : B';
		op: 'aC : C';
		op: 'aD : D';
		op: 'foo(A) : A';
		signature
]

{ #category : #example }
LzExamples >> simpleContext [
	<gtExample>
	^ self simpleContextBuilder context
]

{ #category : #example }
LzExamples >> simpleContextBuilder [
	<gtExample>
	^ LzContextBuilder new
		sort: 'Foo';
		op: 'aFoo : Foo';
		op: 'aFoo(Foo) : Foo';
		op: 'Foo + Foo : Foo';
		op: 'Foo[Foo] : Foo';
		op: 'Foo^(Foo) : Foo';
		op: 'Foo\(Foo) : Foo'.
]

{ #category : #example }
LzExamples >> simpleContextRules [
	<gtExample>
	^ {
		'aFoo â‡’ aFoo'.
		'aFoo(aFoo) â‡’ aFoo'.
		'âˆ€ someFoo_:Foo aFoo(someFoo_) â‡’ someFoo_'.
	} collect: [ :each |
		| rule |
		rule := self simpleContext rule: each.
		self assert: rule asLeibnizSyntaxString equals: each.
		rule ]
]

{ #category : #example }
LzExamples >> simpleContextTermMatches [
	<gtExample>
	| context |
	context := self simpleContext.
	^ {
		{ 'âˆ€ foo_:Foo foo_'. 'aFoo'.  {'foo_' -> 'aFoo'} }.
		{ 'âˆ€ foo_:Foo foo_'. 'aFoo(aFoo)'.  {'foo_' -> 'aFoo(aFoo)'} }.
		{ 'âˆ€ foo_:Foo aFoo(foo_)'. 'aFoo(aFoo)'. {'foo_' -> 'aFoo'} }.
		{ 'âˆ€ foo_:Foo (foo_ + foo_)'. 'aFoo + aFoo'. {'foo_' -> 'aFoo'} }.
		{ 'âˆ€ foo_:Foo aFoo(foo_)'. 'aFoo'. {} }
	} collect: [ :each |
		| pattern term bindings result |
		pattern := context pattern: each first.
		term := context term: each second.
		bindings := pattern match: term.
		result := each third collect: [ :eachEntry |
					(LzVarName for: eachEntry key)
						-> (context term: eachEntry value) ].
		self assert: bindings bindings equals: result asDictionary.
		bindings ]
]

{ #category : #example }
LzExamples >> simpleContextTerms [
	<gtExample>
	^ {
		'aFoo'.
		'aFoo(aFoo)'.
		'aFoo(aFoo + aFoo)'.
		'aFoo[aFoo]'.
		'aFoo^(aFoo)'.
		'aFoo\(aFoo)'
	} collect: [ :each |
		| term |
		term := self simpleContext term: each.
		self assert: term asLeibnizSyntaxString equals: each.
		term ]
]

{ #category : #example }
LzExamples >> sortGraphWithSubsorts [
	<gtExample>
	| sortGraph |
	sortGraph := (LzSortGraphBuilder new
		sort: 'A';
		sort: 'B';
		sort: 'C';
		sort: 'D';
		subsort: 'B âŠ† A';
		subsort: 'C âŠ† A';
		subsort: 'D âŠ† B';
		subsort: 'D âŠ† C')
		sortGraph.
	self assert: (sortGraph sort: 'B') <= (sortGraph sort: 'A').
	self assert: (sortGraph sort: 'C') <= (sortGraph sort: 'A').
	self assert: (sortGraph sort: 'D') <= (sortGraph sort: 'A').
	self assert: ((sortGraph sort: 'A') <= (sortGraph sort: 'B')) not.
	self assert: ((sortGraph sort: 'B') <= (sortGraph sort: 'C')) not.
	self assert: ((sortGraph sort: 'C') <= (sortGraph sort: 'B')) not.
	^ sortGraph
]

{ #category : #example }
LzExamples >> stringOperations [
	<gtExample>
	| context |
	context := LzBuiltinContexts stringContext.
	^ {
		{ '"" + ""'. '""' }.
		{ '"abc" + "xyz"'. '"abcxyz"'}.
		{ '"abc" + ""'. '"abc"'}.
	}
	collect: [ :each |
		| term result |
		term := context term: each first.
		result := context reduce: term.
		self assert: result equals: (context term: each second).
		{ term. result } ]
]

{ #category : #example }
LzExamples >> stringTerms [
	<gtExample>
	| context |
	context := LzBuiltinContexts stringContext.
	^ {
		{ '""'. 'string'. }.
		{ '"abc"'. 'string' }.
	}
	collect: [ :each |
		| term |
		term := context term: each first.
		self assert: term sort asLeibnizSyntaxString equals: each second.
		term  ]
]

{ #category : #example }
LzExamples >> termsForSignatureWithSubsorts [
	<gtExample>
	^ {
		'anA'. 'aB'. 'aC'. 'aD'.
		'foo(anA)'. 'foo(aB)'. 'foo(aC)'. 'foo(aD)'.
	} collect: [ :each |
		self signatureWithSubsorts term: each ]
]
