Class {
	#name : #LzExamples,
	#superclass : #Object,
	#traits : 'TGtExampleAssertable',
	#classTraits : 'TGtExampleAssertable classTrait',
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #example }
LzExamples >> bagContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listContext;
		include: LzBuiltinContexts integerContext;
		sort: 'collection';
		sort: 'bag(ð•Š, â„•)';
		subsort: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• list(?s, ?n) âŠ† bag(?s, ?n)';
		subsort: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• bag(?s, ?n) âŠ† collection';
		subsort: 'âˆ… âŠ† collection';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• âˆ€ ?m:â„• (bag(?s, ?n)) ** (bag(?s, ?m)) : bag(?s, ?n + ?m)';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• (bag(?s, ?n)) ** ?s : bag(?s, ?n + 1)';
		op: 'âˆ€ ?s:ð•Š âˆ… ** ?s : bag(?s, 1)';
		op: 'size(collection) : â„•';
		context
]

{ #category : #example }
LzExamples >> bagRules [
	<gtExample>
	^ {
		'âˆ… ++ 1 â‡’ âˆ…'.
		'length(âˆ…) â‡’ 0'.
	} collect: [ :each |
		| rule |
		rule := self bagContext rule: each.
		self assert: rule asLeibnizSyntaxString equals: each.
		rule ]
]

{ #category : #example }
LzExamples >> bagSignature [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self bagSortGraph;
		include: self listSignature;
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• âˆ€ ?m:â„• (bag(?s, ?n)) ** (bag(?s, ?m)) : bag(?s, ?n + ?m)';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• (bag(?s, ?n)) ** ?s : bag(?s, ?n + 1)';
		op: 'âˆ€ ?s:ð•Š âˆ… ** ?s : bag(?s, 1)';
		signature
]

{ #category : #example }
LzExamples >> bagSortContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listSortContext;
		op: 'collection : ð•Š';
		op: 'bag(ð•Š, â„•) : ð•Š';
		op: 'â„• : ð•Š';
		axiom: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• list(?s, ?n) âŠ† bag(?s, ?n)';
		axiom: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• bag(?s, ?n) âŠ† collection';
		axiom: 'âˆ… âŠ† collection';
		context
]

{ #category : #example }
LzExamples >> bagSortGraph [
	<gtExample>
	^ LzSortGraphBuilder new
		sortContext: self bagSortContext;
		sortGraph
]

{ #category : #accessing }
LzExamples >> booleanContext [
	<gtExample>
	^ LzContextBuilder new
		include: LzBuiltinContexts truthContext;
		op: 'Â¬(boolean) : boolean';
		op: 'boolean âˆ§ boolean : boolean';
		op: 'boolean âˆ¨ boolean : boolean';
		op: 'boolean âŠ» boolean : boolean';
		var: '?X : boolean';
		var: '?Y : boolean';
		context
]

{ #category : #example }
LzExamples >> booleanUnifications [
	<gtExample>
	| c |
	c := self booleanContext.
	^ {
		{'true'. '?X'. '(?X=true)'}.
		{'Â¬(?X)'. 'Â¬(true)'. '(?X=true)'}.
		{'?X'. 'Â¬(true)'. '(?X=Â¬(true))'}.
		{'true âŠ» false âŠ» true âŠ» Â¬(true)'. 'true âŠ» false âŠ» ?X âŠ» ?Y'. '(?X=true, ?Y=Â¬(true))'}.
		{'false âŠ» ?X âŠ» true âŠ» Â¬(true)'. 'false âŠ» true âŠ» ?X âŠ» ?Y'. '(?X=true, ?Y=Â¬(true))'}.
		{'?X âŠ» Â¬(?X)'. 'false âŠ» Â¬(?X)'. '(?X=false)'}.
		{'?X âŠ» Â¬(?Y)'. 'false âŠ» Â¬(?Y)'. '(?Y, ?X=false)'}.
		{'false âŠ» Â¬(?X)'. 'false âŠ» Â¬(?Y)'. '(?X=?Y)'}.
		{'true'. 'false'.  '(failure #nonUnifiableTerms: false, true)' }.
		{'âˆ€ ?foo:boolean Â¬(?foo)'. 'âˆ€ ?bar:boolean Â¬(?bar)'. '(?bar=?foo)'}
	} collect: [ :each |
		| unification string |
		unification := (c pattern: each first) unify: (c pattern: each  second).
		string := unification printString.
		self assert: (string allButFirst: (string findString: '(') - 1) equals: each third.
		unification ]
]

{ #category : #example }
LzExamples >> integerArithmetic [
	<gtExample>
	| context |
	context := LzBuiltinContexts integerContext.
	^ {
		{ '-(2)'. '-2' }.
		{ '2 + 2'. '4'}.
		{ '2 - 2'. '0'}.
		{ '3 Ã— 2'. '6'}.
		{ '3 div 2'. '1'}.		
		{ '3 rem 2'. '1'}.
		{ '3^{2}'. '9'}.
		{ '3^{0}'. '1'}.
		{ '0^{2}'. '0'}.
		{ '2 < 3'. 'true'}.
		{ '2 > 3'. 'false'}.
	}
	collect: [ :each |
		| term result |
		term := context term: each first.
		result := context reduce: term.
		self assert: result equals: (context term: each second).
		{ term. result } ]
]

{ #category : #example }
LzExamples >> integerTerms [
	<gtExample>
	^ {
		'0'.
		'1'.
		'-1'.
	}
	collect: [ :each |
		 LzBuiltinContexts integerContext term: each ]
]

{ #category : #example }
LzExamples >> listContext [
	<gtExample>
	^ LzContextBuilder new
		includeSortContext: LzBuiltinContexts integerContext;
		include: LzBuiltinContexts truthContext;
		sort: 'element';
		sort: 'element.special';
		sort: 'âˆ…';
		sort: 'list(ð•Š, â„•)';
		subsort: 'element.special âŠ† element';		
		op: 'âˆ… : âˆ…';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• âˆ€ ?m:â„• ',
				'(list(?s, ?n)) ++ (list(?s, ?m)) : list(?s, ?n + ?m)';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• ',
				'(list(?s, ?n)) ++ ?s : list(?s, ?n + 1)';
		op: 'âˆ€ ?s:ð•Š ',
				'âˆ… ++ ?s : list(?s, 1)';
		op: 'anElement : element';
		context
]

{ #category : #example }
LzExamples >> listPlusIntegerContext [
	<gtExample>
	^ LzContextBuilder new
		include: self listContext;
		include: LzBuiltinContexts integerContext;
		context
]

{ #category : #example }
LzExamples >> listSignature [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self listSortGraph;
		op: 'âˆ… : âˆ…';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• âˆ€ ?m:â„• ',
				'(list(?s, ?n)) ++ (list(?s, ?m)) : list(?s, ?n + ?m)';
		op: 'âˆ€ ?s:ð•Š âˆ€ ?n:â„• ',
				'(list(?s, ?n)) ++ ?s : list(?s, ?n + 1)';
		op: 'âˆ€ ?s:ð•Š ',
				'âˆ… ++ ?s : list(?s, 1)';
		op: 'anElement : element';
		signature
]

{ #category : #example }
LzExamples >> listSortContext [
	<gtExample>
	^ (LzContextBuilder new
		include: LzBuiltinContexts sortContext;
		include: LzBuiltinContexts integerContext;
		op: 'element : ð•Š';
		op: 'element.special : ð•Š';
		op: 'âˆ… : ð•Š';
		op: 'list(ð•Š, â„•) : ð•Š';
		axiom: 'element.special âŠ† element')
		context.
]

{ #category : #example }
LzExamples >> listSortGraph [
	<gtExample>
	^ LzSortGraphBuilder new
		sortContext: self listSortContext;
		sortGraph
]

{ #category : #example }
LzExamples >> listTerms [
	<gtExample>
	^ {
		'âˆ…'.
		'âˆ… ++ 1'.
		'âˆ… ++ 1 ++ 2'.
	}
	collect: [ :each |
		 self listPlusIntegerContext term: each ]
]

{ #category : #accessing }
LzExamples >> signatureWithSubsorts [
	<gtExample>
	^ LzSignatureBuilder new
		sortGraph: self sortGraphWithSubsorts;
		op: 'anA : A';
		op: 'aB : B';
		op: 'aC : C';
		op: 'aD : D';
		op: 'foo(A) : A';
		var: '?A : A';
		var: '?B : B';
		var: '?C : C';
		var: '?D : D';
		signature
]

{ #category : #example }
LzExamples >> simpleContext [
	<gtExample>
	^ self simpleContextBuilder context
]

{ #category : #example }
LzExamples >> simpleContextBuilder [
	<gtExample>
	^ LzContextBuilder new
		sort: 'Foo';
		op: 'aFoo : Foo';
		op: 'aFoo(Foo) : Foo';
		op: 'Foo + Foo : Foo';
		op: 'Foo[Foo] : Foo';
		op: 'Foo^{Foo} : Foo';
		op: 'Foo_{Foo} : Foo';
		var: '?foo : Foo'.
]

{ #category : #example }
LzExamples >> simpleContextRules [
	<gtExample>
	^ {
		'aFoo â‡’ aFoo'.
		'aFoo(?foo) â‡’ aFoo'.
		'âˆ€ ?someFoo:Foo aFoo(?someFoo) â‡’ ?someFoo'.
	} collect: [ :each |
		| rule |
		rule := self simpleContext rule: each.
		self assert: rule asLeibnizSyntaxString equals: each.
		rule ]
]

{ #category : #example }
LzExamples >> simpleContextTermMatches [
	<gtExample>
	| context |
	context := self simpleContext.
	^ {
		{ '?foo'. 'aFoo'.  {'?foo' -> 'aFoo'} }.
		{ '?foo'. 'aFoo(aFoo)'.  {'?foo' -> 'aFoo(aFoo)'} }.
		{ 'aFoo(?foo)'. 'aFoo(aFoo)'. {'?foo' -> 'aFoo'} }.
		{ '(?foo + ?foo)'. 'aFoo + aFoo'. {'?foo' -> 'aFoo'} }.
		{ 'aFoo(?foo)'. 'aFoo'. {} }
	} collect: [ :each |
		| pattern term bindings result |
		pattern := context pattern: each first.
		term := context term: each second.
		bindings := pattern match: term.
		result := each third collect: [ :eachEntry |
					(LzVarName for: eachEntry key)
						-> (context term: eachEntry value) ].
		self assert: bindings bindings equals: result asDictionary.
		bindings ]
]

{ #category : #example }
LzExamples >> simpleContextTerms [
	<gtExample>
	^ {
		'aFoo'.
		'aFoo(aFoo)'.
		'aFoo(aFoo(?foo))'.
		'aFoo(aFoo + aFoo)'.
		'aFoo[aFoo]'.
		'aFoo^{aFoo}'.
		'aFoo_{aFoo}'
	} collect: [ :each |
		| term |
		term := self simpleContext term: each.
		self assert: term asLeibnizSyntaxString equals: each.
		term ]
]

{ #category : #example }
LzExamples >> sortGraphWithSubsorts [
	<gtExample>
	| sortGraph |
	sortGraph := (LzSortGraphBuilder new
		sort: 'A';
		sort: 'B';
		sort: 'C';
		sort: 'D';
		subsort: 'B âŠ† A';
		subsort: 'C âŠ† A';
		subsort: 'D âŠ† B';
		subsort: 'D âŠ† C')
		sortGraph.
	self assert: (sortGraph sort: 'B') <= (sortGraph sort: 'A').
	self assert: (sortGraph sort: 'C') <= (sortGraph sort: 'A').
	self assert: (sortGraph sort: 'D') <= (sortGraph sort: 'A').
	self assert: ((sortGraph sort: 'A') <= (sortGraph sort: 'B')) not.
	self assert: ((sortGraph sort: 'B') <= (sortGraph sort: 'C')) not.
	self assert: ((sortGraph sort: 'C') <= (sortGraph sort: 'B')) not.
	^ sortGraph
]

{ #category : #example }
LzExamples >> termsForSignatureWithSubsorts [
	<gtExample>
	^ {
		'anA'. 'aB'. 'aC'. 'aD'.
		"'foo(anA)'. 'foo(aB)'. 'foo(aC)'. 'foo(aD)'."
	} collect: [ :each |
		self signatureWithSubsorts term: each ]
]
