"
Builtin contexts are contexts that cannot be defined in Leibniz itself, because they make use of builtin terms such as numbers or strings. {{gtMethod:name=LzBuiltinContexts class>>#truthContext}} is an exception: it could very well be defined as a standard Leibniz context, but since it is used by the number contexts, it is part of the builtin contexts as well.

"
Class {
	#name : #LzBuiltinContexts,
	#superclass : #Object,
	#classVars : [
		'EqualityContext',
		'IntegerContext',
		'RationalNumberContext',
		'StringContext',
		'TruthContext'
	],
	#category : #'Leibniz2-Leibniz2'
}

{ #category : #accessing }
LzBuiltinContexts class >> arrayContext [
	| builder |
	builder := LzContextBuilder new
				includeSortContext: LzBuiltinContexts integerContext;
				include: LzBuiltinContexts integerContext;
				builtin: #arrays.
	self arraySortsFor: builder.
	self arrayOpsFor: builder.
	^ builder context
]

{ #category : #accessing }
LzBuiltinContexts class >> arrayOpsFor: builder [
	builder
		op: 'โ s_:๐ shape(Array(s_)) : Array(โ)';
		rule: 'โ s__:๐ โ A_:Array(s__) shape(A_) โ ''A shapeAsArrayTerm'':nil'.
]

{ #category : #private }
LzBuiltinContexts class >> arraySortsFor: builder [
	builder
		sort: 'Array(๐)';
		sort: 'Array(๐, โ)';
		subsort: 'โ s_:๐ โ i1_:โ ',
					'Array(s_, i1_) โ Array(s_)';
		sort: 'Array(๐, โ, โ)';
		subsort: 'โ s_:๐ โ i1_:โ โ i2_:โ ',
					'Array(s_, i1_, i2_) โ Array(s_, i1_)';
		sort: 'Array(๐, โ, โ, โ)';
		subsort: 'โ s_:๐ โ i1_:โ โ i2_:โ โ i3_:โ ',
					'Array(s_, i1_, i2_, i3_) โ Array(s_, i1_, i2_)';
		sort: 'Array(๐, โ, โ, โ, โ)';
		subsort: 'โ s_:๐ โ i1_:โ โ i2_:โ โ i3_:โ โ i4_:โ ',
					'Array(s_, i1_, i2_, i3_, i4_) โ Array(s_, i1_, i2_, i3_)'
]

{ #category : #accessing }
LzBuiltinContexts class >> equalityContext [
	EqualityContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			op: 'โ s_:๐ s_ == s_ : ๐น';
			axiom: 'โ s__:๐ โ x_:s__ โ y_:s__ (x_ == y_) = (y_ == x_)';
			rule: 'โ s__:๐ โ X_:s__ โ Y_:s__ X_ == Y_ โ ''X = Y'':LzBooleanTerm'.
		EqualityContext := builder context ].
	^ EqualityContext
]

{ #category : #private }
LzBuiltinContexts class >> integerAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'โ x_:โค โ y_:โค  x_ + y_ = y_ + x_';
		axiom: 'โ x_:โค โ y_:โค  โ z_:โค  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: 'โ x_:โค โ y_:โค  x_ ร y_ = y_ ร x_';
		axiom: 'โ x_:โค โ y_:โค  โ z_:โค  (x_ ร y_) ร z_ = x_ ร (y_ ร z_)'.
]

{ #category : #accessing }
LzBuiltinContexts class >> integerContext [
	IntegerContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers.
		self integerSortsFor: builder.
		self integerOpsFor: builder.
		self integerAxiomsFor: builder.
		self integerRulesFor: builder.
		IntegerContext := builder context ].
	^ IntegerContext
]

{ #category : #private }
LzBuiltinContexts class >> integerOpsFor: aContextBuilder [
	aContextBuilder
		"Predecessor and successor for natural numbers"
		op: 'succ(โ) : โ.nz';
		op: 'pred(โ.nz) : โ';
		"Arithmetic operators"
		op: 'โค + โค : โค';
		op: 'โ + โ : โ';
		op: 'โ.nz + โ.nz : โ.nz';
		op: 'โ.nz + โ : โ.nz';
		op: 'โ + โ.nz : โ.nz';
		op: 'โค - โค : โค';
		op: '-(โค) : โค';
		op: 'โค ร โค : โค';
		op: 'โ ร โ : โ';
		op: 'โ.nz ร โ.nz : โ.nz';
		op: 'โค.nz ร โค.nz : โค.nz';
		op: 'โค div โค.nz : โค';
		op: 'โ div โ.nz : โ';
		op: 'โค rem โค.nz : โค';
		op: 'โ rem โ.nz : โ';
		op: 'โค^(โ.nz) : โค';
		op: 'โ^(โ.nz) : โ';
		op: 'โ.nz^(โ.nz) : โ.nz';
		op: 'โค.nz^(โ.nz) : โค.nz';
		op: 'โค.nz^(zero) : โ.nz';
		op: 'abs(โค) : โ';
		op: 'abs(โค.nz) : โ.nz';
		"Comparison operators"
		op: 'โค < โค : ๐น';
		op: 'โค > โค : ๐น';
		op: 'โค โค โค : ๐น';
		op: 'โค โฅ โค : ๐น'.
]

{ #category : #private }
LzBuiltinContexts class >> integerRulesFor: aContextBuilder [
	aContextBuilder
		"predecessor/successor rules"
		rule: 'โ x_:โ.nz pred(x_) โ ''x - 1'':LzIntegerTerm';
		rule: 'โ x_:โ succ(x_) โ ''x + 1'':LzIntegerTerm';
		"addition rules"
		rule: 'โ x_:โค โ zero_:zero x_ + zero_ โ x_';
		rule: 'โ x_:โค โ zero_:zero zero_ + x_ โ x_';
		rule: 'โ x_:โค โ y_:โค x_ + y_ โ ''x + y'':LzIntegerTerm';
		"subtraction rules"
		rule: 'โ x_:โค โ zero_:zero x_ - zero_ โ x_';
		rule: 'โ x_:โค โ zero_:zero zero_ - x_ โ -(x_)';
		rule: 'โ x_:โค โ y_:โค x_ - y_ โ ''x - y'':LzIntegerTerm';
		rule: 'โ zero_:zero -(zero_) โ 0';
		rule: 'โ x_:โค -(x_) โ ''x negated'':LzIntegerTerm';
		"multiplication rules"
		rule: 'โ x_:โค โ zero_:zero x_ ร zero_ โ 0';
		rule: 'โ x_:โค โ zero_:zero zero_ ร x_ โ 0';
		rule: 'โ x_:โค 1 ร x_ โ x_';
		rule: 'โ x_:โค x_ ร 1 โ x_';
		rule: 'โ x_:โค โ y_:โค x_ ร y_ โ ''x * y'':LzIntegerTerm';
		"division rules"
		rule: 'โ x_:โค.nz โ zero_:zero zero_ div x_ โ 0';
		rule: 'โ x_:โค x_ div 1 โ x_';
		rule: 'โ x_:โค โ y_:โค.nz x_ div y_ โ ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'โ x_:โค.nz โ zero_:zero zero_ rem x_ โ 0';
		rule: 'โ x_:โค x_ rem 1 โ 0';
		rule: 'โ x_:โค โ y_:โค.nz x_ rem y_ โ ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"exponentiation rules"
		rule: 'โ x_:โค.nz โ zero_:zero x_^(zero_) โ 1';
		rule: 'โ x_:โ.nz โ zero_:zero zero_^(x_) โ 0';
		rule: 'โ x_:โค โ y_:โ.nz x_^(y_) โ ''x raisedTo: y'':LzIntegerTerm';
		"abs rules"
		rule: 'โ x_:โ abs(x_) โ x_';
		rule: 'โ x_:โค abs(x_) โ -(x_) | x_ < 0';
		rule: 'โ x_:โค abs(x_) โ ''x abs'':LzIntegerTerm';
		"comparison rules"
		rule: 'โ x_:โค โ y_:โค x_ < y_ โ ''x < y'':LzBooleanTerm';
		rule: 'โ x_:โค โ y_:โค x_ > y_ โ ''x > y'':LzBooleanTerm';
		rule: 'โ x_:โค โ y_:โค x_ โค y_ โ ''x <= y'':LzBooleanTerm';
		rule: 'โ x_:โค โ y_:โค x_ โฅ y_ โ ''x >= y'':LzBooleanTerm'.
]

{ #category : #private }
LzBuiltinContexts class >> integerSortsFor: aContextBuilder [
	aContextBuilder
		"Natural numbers"
		sort: 'โ';
		sort: 'โ.nz';
		sort: 'zero';
		subsort: 'zero โ โ';
		subsort: 'โ.nz โ โ';
		"Integers"
		sort: 'โค';
		sort: 'โค.nz';
		subsort: 'โ โ โค';
		subsort: 'โค.nz โ โค';
		subsort: 'โ.nz โ โค.nz'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalAxiomsFor: aContextBuilder [
	aContextBuilder
		"addition axioms"
		axiom: 'โ x_:โ โ y_:โ  x_ + y_ = y_ + x_';
		axiom: 'โ x_:โ โ y_:โ  โ z_:โ  (x_ + y_) + z_ = x_ + (y_ + z_)';
		"multiplication axioms"
		axiom: 'โ x_:โ โ y_:โ  x_ ร y_ = y_ ร x_';
		axiom: 'โ x_:โ โ y_:โ  โ z_:โ  (x_ ร y_) ร z_ = x_ ร (y_ ร z_)'.
]

{ #category : #accessing }
LzBuiltinContexts class >> rationalNumberContext [
	RationalNumberContext ifNil: [
		| builder |
		builder := LzContextBuilder new
			include: self truthContext;
			builtin: #integers;
			builtin: #rationalNumbers.
		self integerSortsFor: builder.
		self rationalSortsFor: builder.
		self integerOpsFor: builder.
		self rationalOpsFor: builder.
		"No integerAxioms, because they would be redundant."
		self rationalAxiomsFor:  builder.
		"No integerRules, the few that are required are repeated in rationalRules."
		self rationalRulesFor: builder.
		RationalNumberContext := builder context ].
	^ RationalNumberContext
]

{ #category : #private }
LzBuiltinContexts class >> rationalOpsFor: aContextBuilder [
	aContextBuilder
		"Arithmetic operators"
		op: 'โ + โ : โ';
		op: 'โ.p + โ.p : โ.p';
		op: 'โ.nn + โ.nn : โ.nn';
		op: 'โ - โ : โ';
		op: '-(โ) : โ';
		op: 'โ ร โ : โ';
		op: 'โ.p ร โ.p : โ.p';
		op: 'โ.nn ร โ.nn : โ.nn';
		op: 'โ.nz ร โ.nz : โ.nz';
		op: 'โ รท โ.nz : โ';
		op: 'โ.nz รท โ.nz : โ.nz';
		op: 'โ.nn รท โ.p : โ.nn';
		op: 'โ.p รท โ.p : โ.p';
		op: 'โ.nz^(โค.nz) : โ.nz';
		op: 'โ.p^(โค.nz) : โ.p';
		op: 'โ.nz^(zero) : โ.nz';
		op: 'abs(โ) : โ.nn';
		op: 'abs(โ.nz) : โ.p';
		"Comparison operators"
		op: 'โ < โ : ๐น';
		op: 'โ > โ : ๐น';
		op: 'โ โค โ : ๐น';
		op: 'โ โฅ โ : ๐น'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalRulesFor: aContextBuilder [
	aContextBuilder
		"addition rules"
		rule: 'โ x_:โ โ z_:zero x_ + z_ โ x_';
		rule: 'โ x_:โ โ z_:zero z_ + x_ โ x_';
		rule: 'โ x_:โ โ y_:โ x_ + y_ โ ''x + y'':LzRationalNumberTerm';
		rule: 'โ x_:โค โ y_:โค x_ + y_ โ ''x + y'':LzIntegerTerm';
		"Subtraction rules"
		rule: 'โ x_:โ โ z_:zero x_ - z_ โ x_';
		rule: 'โ x_:โ โ z_:zero z_ - x_ โ -(x_)';
		rule: 'โ x_:โค โ y_:โค x_ - y_ โ ''x - y'':LzIntegerTerm';
		rule: 'โ x_:โ โ y_:โ x_ - y_ โ ''x - y'':LzRationalNumberTerm';
		"Negation rules"
		rule: 'โ z_:zero -(z_) โ 0';
		rule: 'โ x_:โค -(x_) โ ''x negated'':LzIntegerTerm';
		rule: 'โ x_:โ -(x_) โ ''x negated'':LzRationalNumberTerm';
		"Multiplication rules"
		rule: 'โ x_:โ โ z_:zero x_ ร z_ โ 0';
		rule: 'โ x_:โ โ z_:zero z_ ร x_ โ 0';
		rule: 'โ x_:โ 1 ร x_ โ x_';
		rule: 'โ x_:โ x_ ร 1 โ x_';
		rule: 'โ x_:โค โ y_:โค x_ ร y_ โ ''x * y'':LzIntegerTerm';
		rule: 'โ x_:โ โ y_:โ x_ ร y_ โ ''x * y'':LzRationalNumberTerm';
		"Division rules"
		rule: 'โ x_:โ.nz โ z_:zero z_ รท x_ โ 0';
		rule: 'โ x_:โ x_ รท 1 โ x_';
		rule: 'โ x_:โ โ y_:โ.nz x_ รท y_ โ ''x / y'':LzRationalNumberTerm';
		"Integer div and rem rules"
		rule: 'โ x_:โค.nz โ z_:zero z_ div x_ โ 0';
		rule: 'โ x_:โค x_ div 1 โ x_';
		rule: 'โ x_:โค โ y_:โค.nz x_ div y_ โ ''(x abs // y abs) * x sign * y sign'':LzIntegerTerm';
		rule: 'โ x_:โค.nz โ z_:zero z_ rem x_ โ 0';
		rule: 'โ x_:โค x_ rem 1 โ 0';
		rule: 'โ x_:โค โ y_:โค.nz x_ rem y_ โ ''(x abs % y abs) * x sign * y sign'':LzIntegerTerm';
		"Exponentiation rules"
		rule: 'โ x_:โ.nz โ z_:zero x_^(z_) โ 1';
		rule: 'โ x_:โ.nz โ z_:zero z_^(x_) โ 0';
		rule: 'โ x_:โค โ y_:โ.nz x_^(y_) โ ''x raisedTo: y'':LzIntegerTerm';
		rule: 'โ x_:โ.nz โ y_:โค.nz x_^(y_) โ ''x raisedTo: y'':LzRationalNumberTerm';
		"Abs rules"
		rule: 'โ x_:โ.nn abs(x_) โ x_';
		rule: 'โ x_:โ abs(x_) โ -(x_) | x_ < 0';
		rule: 'โ x_:โค abs(x_) โ ''x abs'':LzIntegerTerm';
		rule: 'โ x_:โ abs(x_) โ ''x abs'':LzRationalNumberTerm';
		"Comparison rules"
		rule: 'โ x_:โ โ y_:โ x_ < y_ โ ''x < y'':LzBooleanTerm';
		rule: 'โ x_:โ โ y_:โ x_ > y_ โ ''x > y'':LzBooleanTerm';
		rule: 'โ x_:โ โ y_:โ x_ โค y_ โ ''x <= y'':LzBooleanTerm';
		rule: 'โ x_:โ โ y_:โ x_ โฅ y_ โ ''x >= y'':LzBooleanTerm'.
]

{ #category : #private }
LzBuiltinContexts class >> rationalSortsFor: aContextBuilder [
	aContextBuilder
		"Rational numbers"
		sort: 'โ';
		sort: 'โ.nn';
		sort: 'โ.nz';
		sort: 'โ.p';
		subsort: 'โ.nz โ โ';
		subsort: 'โ.p โ โ.nz';
		subsort: 'โ.nn โ โ';
		subsort: 'โ.p โ โ.nn';
		subsort: 'โ โ โ.nn';
		subsort: 'โ.nz โ โ.p';
		subsort: 'โค โ โ';
		subsort: 'โค.nz โ โ.nz'.
]

{ #category : #resetting }
LzBuiltinContexts class >> reset [
	TruthContext := nil.
	IntegerContext := nil.
	RationalNumberContext := nil.
	StringContext := nil.
]

{ #category : #accessing }
LzBuiltinContexts class >> sortContext [
	^ LzSortHierarchyRoot uniqueInstance sortContext
]

{ #category : #accessing }
LzBuiltinContexts class >> stringContext [
	StringContext ifNil: [
		StringContext :=
			LzContextBuilder new
				builtin: #strings;
				sort: 'string';
				op: 'string + string : string';
				rule: 'โ a_:string โ b_:string a_ + b_ โ ''a, b'':LzStringTerm';
				context ].
	^ StringContext
]

{ #category : #accessing }
LzBuiltinContexts class >> truthContext [
	TruthContext ifNil: [
		TruthContext :=
			LzContextBuilder new
				sort: '๐น';
				op: 'โค : ๐น';
				op: 'โฅ : ๐น';
				context ].
	^ TruthContext
]
