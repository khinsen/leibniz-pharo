"
This is a ${class:name=LeibnizDocument}$ holding a few example contexts.
"
Class {
	#name : #LeibnizExamples,
	#superclass : #LeibnizDocument,
	#classInstVars : [
		'uniqueInstance'
	],
	#category : #'Leibniz-Examples'
}

{ #category : #initialization }
LeibnizExamples >> createBooleanContext [
	| contextElement |
	contextElement := XMLDOMParser parse: '<context id="boolean"><includes><include document="e513fb1f0504a951919688029321eaa02b4e2ad014c0979c4b602b946f9cafc8" mode="use" context="truth"/></includes><context-refs/><sorts><sort id="boolean"/></sorts><subsorts/><vars><var id="X" sort="boolean"/><var id="Y" sort="boolean"/></vars><ops><op id="_âˆ¨"><arity><sort id="boolean"/><sort id="boolean"/></arity><sort id="boolean"/></op><op id="_âŠ»"><arity><sort id="boolean"/><sort id="boolean"/></arity><sort id="boolean"/></op><op id="_âˆ§"><arity><sort id="boolean"/><sort id="boolean"/></arity><sort id="boolean"/></op><op id="Â¬"><arity><sort id="boolean"/></arity><sort id="boolean"/></op></ops><rules><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="Â¬"><term-or-var name="X"/></term></pattern><condition/><replacement><term op="_âŠ»"><term-or-var name="true"/><term-or-var name="X"/></term></replacement></rule><rule><vars><var id="X" sort="boolean"/><var id="Y" sort="boolean"/></vars><pattern><term op="_âˆ¨"><term-or-var name="X"/><term-or-var name="Y"/></term></pattern><condition/><replacement><term op="_âŠ»"><term op="_âŠ»"><term-or-var name="X"/><term-or-var name="Y"/></term><term op="_âˆ§"><term-or-var name="X"/><term-or-var name="Y"/></term></term></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âˆ§"><term-or-var name="X"/><term-or-var name="false"/></term></pattern><condition/><replacement><term-or-var name="false"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âˆ§"><term-or-var name="false"/><term-or-var name="X"/></term></pattern><condition/><replacement><term-or-var name="false"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âˆ§"><term-or-var name="X"/><term-or-var name="true"/></term></pattern><condition/><replacement><term-or-var name="X"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âˆ§"><term-or-var name="true"/><term-or-var name="X"/></term></pattern><condition/><replacement><term-or-var name="X"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âˆ§"><term-or-var name="X"/><term-or-var name="X"/></term></pattern><condition/><replacement><term-or-var name="X"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âŠ»"><term-or-var name="X"/><term-or-var name="false"/></term></pattern><condition/><replacement><term-or-var name="X"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âŠ»"><term-or-var name="false"/><term-or-var name="X"/></term></pattern><condition/><replacement><term-or-var name="X"/></replacement></rule><rule><vars><var id="X" sort="boolean"/></vars><pattern><term op="_âŠ»"><term-or-var name="X"/><term-or-var name="X"/></term></pattern><condition/><replacement><term-or-var name="false"/></replacement></rule><rule><vars><var id="Z" sort="boolean"/><var id="X" sort="boolean"/><var id="Y" sort="boolean"/></vars><pattern><term op="_âˆ§"><term-or-var name="X"/><term op="_âŠ»"><term-or-var name="Y"/><term-or-var name="Z"/></term></term></pattern><condition/><replacement><term op="_âŠ»"><term op="_âˆ§"><term-or-var name="X"/><term-or-var name="Y"/></term><term op="_âˆ§"><term-or-var name="X"/><term-or-var name="Z"/></term></term></replacement></rule></rules><assets/></context>'.
	self fromXML: contextElement.

]

{ #category : #initialization }
LeibnizExamples >> createDerivativeContext [
	| contextElement |
	contextElement := XMLDOMParser parse: '<context id="derivatives-â„â†’â„"><includes><include mode="extend" context="â„â†’â„"/></includes><context-refs/><sorts/><subsorts/><vars/><ops><op id="ð’Ÿ"><arity><sort id="â„â†’â„"/></arity><sort id="â„â†’â„"/></op></ops><rules><rule><vars/><pattern><term op="ð’Ÿ"><term op="_+"><term-or-var name="f"/><term-or-var name="g"/></term></term></pattern><condition/><replacement><term op="_+"><term op="ð’Ÿ"><term-or-var name="f"/></term><term op="ð’Ÿ"><term-or-var name="g"/></term></term></replacement></rule><rule><vars/><pattern><term op="ð’Ÿ"><term op="_-"><term-or-var name="f"/><term-or-var name="g"/></term></term></pattern><condition/><replacement><term op="_-"><term op="ð’Ÿ"><term-or-var name="f"/></term><term op="ð’Ÿ"><term-or-var name="g"/></term></term></replacement></rule><rule><vars/><pattern><term op="ð’Ÿ"><term op="_Ã—"><term-or-var name="s"/><term-or-var name="f"/></term></term></pattern><condition/><replacement><term op="_Ã—"><term-or-var name="s"/><term op="ð’Ÿ"><term-or-var name="f"/></term></term></replacement></rule><rule><vars/><pattern><term op="ð’Ÿ"><term op="_Ã—"><term-or-var name="f"/><term-or-var name="g"/></term></term></pattern><condition/><replacement><term op="_+"><term op="_Ã—"><term op="ð’Ÿ"><term-or-var name="f"/></term><term-or-var name="g"/></term><term op="_Ã—"><term-or-var name="f"/><term op="ð’Ÿ"><term-or-var name="g"/></term></term></term></replacement></rule><rule><vars/><pattern><term op="ð’Ÿ"><term op="_â—‹"><term-or-var name="f"/><term-or-var name="g"/></term></term></pattern><condition/><replacement><term op="_Ã—"><term op="_â—‹"><term op="ð’Ÿ"><term-or-var name="f"/></term><term-or-var name="g"/></term><term op="ð’Ÿ"><term-or-var name="g"/></term></term></replacement></rule></rules><assets/></context>'.
	self fromXML: contextElement.

]

{ #category : #initialization }
LeibnizExamples >> createFunctionContext [
	| contextElement |
	contextElement := XMLDOMParser parse: '<context id="â„â†’â„"><includes><include document="e513fb1f0504a951919688029321eaa02b4e2ad014c0979c4b602b946f9cafc8" mode="use" context="real-numbers"/></includes><context-refs/><sorts><sort id="â„â†’â„"/></sorts><subsorts/><vars><var id="s" sort="â„"/><var id="X" sort="â„"/><var id="Y" sort="â„"/><var id="g" sort="â„â†’â„"/><var id="f" sort="â„â†’â„"/></vars><ops><op id="_â—‹"><arity><var id="f" sort="â„â†’â„"/><var id="g" sort="â„â†’â„"/></arity><sort id="â„â†’â„"/></op><op id="_Ã—"><arity><var id="s" sort="â„"/><var id="g" sort="â„â†’â„"/></arity><sort id="â„â†’â„"/></op><op id="[]"><arity><sort id="â„â†’â„"/><sort id="â„"/></arity><sort id="â„"/></op><op id="_-"><arity><var id="f" sort="â„â†’â„"/><var id="g" sort="â„â†’â„"/></arity><sort id="â„â†’â„"/></op><op id="_Ã—"><arity><var id="f" sort="â„â†’â„"/><var id="g" sort="â„â†’â„"/></arity><sort id="â„â†’â„"/></op><op id="_+"><arity><var id="f" sort="â„â†’â„"/><var id="g" sort="â„â†’â„"/></arity><sort id="â„â†’â„"/></op></ops><rules><rule><vars><var id="x" sort="â„"/></vars><pattern><term op="[]"><term op="_+"><term-or-var name="f"/><term-or-var name="g"/></term><term-or-var name="x"/></term></pattern><condition/><replacement><term op="_+"><term op="[]"><term-or-var name="f"/><term-or-var name="x"/></term><term op="[]"><term-or-var name="g"/><term-or-var name="x"/></term></term></replacement></rule><rule><vars><var id="x" sort="â„"/></vars><pattern><term op="[]"><term op="_-"><term-or-var name="f"/><term-or-var name="g"/></term><term-or-var name="x"/></term></pattern><condition/><replacement><term op="_-"><term op="[]"><term-or-var name="f"/><term-or-var name="x"/></term><term op="[]"><term-or-var name="g"/><term-or-var name="x"/></term></term></replacement></rule><rule><vars><var id="x" sort="â„"/></vars><pattern><term op="[]"><term op="_Ã—"><term-or-var name="f"/><term-or-var name="g"/></term><term-or-var name="x"/></term></pattern><condition/><replacement><term op="_Ã—"><term op="[]"><term-or-var name="f"/><term-or-var name="x"/></term><term op="[]"><term-or-var name="g"/><term-or-var name="x"/></term></term></replacement></rule><rule><vars><var id="x" sort="â„"/></vars><pattern><term op="[]"><term op="_Ã—"><term-or-var name="s"/><term-or-var name="g"/></term><term-or-var name="x"/></term></pattern><condition/><replacement><term op="_Ã—"><term-or-var name="s"/><term op="[]"><term-or-var name="g"/><term-or-var name="x"/></term></term></replacement></rule><rule><vars><var id="x" sort="â„"/></vars><pattern><term op="[]"><term op="_â—‹"><term-or-var name="f"/><term-or-var name="g"/></term><term-or-var name="x"/></term></pattern><condition/><replacement><term op="[]"><term-or-var name="f"/><term op="[]"><term-or-var name="g"/><term-or-var name="x"/></term></term></replacement></rule></rules><assets/></context>'.
	self fromXML: contextElement.

]

{ #category : #initialization }
LeibnizExamples >> createMassContext [
	| b |
	b := self newContextBuilderNamed: 'mass'.
	b include: 'real-numbers'
	  fromDocumentWithHash: 'e513fb1f0504a951919688029321eaa02b4e2ad014c0979c4b602b946f9cafc8'
	  inMode: #use.
	b parseAndAddSort: 'mass'.
	b parseAndAddOp: 'mass + mass : mass'.
	b parseAndAddOp: 'â„.p Ã— mass : mass'.
	b parseAndAddOp: 'mass Ã· â„.p : mass'.
	b parseAndAddOp: 'mass Ã· mass : â„.p'.
	b parseAndAddVar: 'M:mass'.
	b parseAndAddVar: 'M1:mass'.
	b parseAndAddVar: 'M2:mass'.
	b parseAndAddVar: 'F:â„.p'.
	b parseAndAddVar: 'F1:â„.p'.
	b parseAndAddVar: 'F2:â„.p'.
	b parseAndAddRule: '(F1 Ã— M) + (F2 Ã— M) â‡’ (F1 + F2) Ã— M'.
	b parseAndAddRule: 'F1 Ã— (F2 Ã— M) â‡’ (F1 Ã— F2) Ã— M'.
	b parseAndAddRule: 'M Ã· F â‡’ (1 Ã· F) Ã— M'.
	b parseAndAddRule: 'M1 Ã· (F Ã— M2) â‡’ (M1 Ã· F) Ã· M2'.
	b parseAndAddRule: '(F Ã— M1) Ã· M2 â‡’ F Ã— (M1 Ã· M2)'.
	b parseAndAddRule: 'M Ã· M â‡’ 1'.
	b build.
]

{ #category : #initialization }
LeibnizExamples >> createMassUnitContext [
	| b |
	b := self newContextBuilderNamed: 'mass-units'.
	b include: 'mass'
	  inMode: #extend.
	b include: 'boolean'
	  inMode: #use.
	b parseAndAddSort: 'mass-unit âŠ† mass'.
	b parseAndAddOp: 'kg : mass-unit'.
	b parseAndAddOp: 'g : mass-unit'.
	b parseAndAddOp: 'mg : mass-unit'.
	b parseAndAddOp: 'mass in mass-unit : mass'.
	b parseAndAddVar: 'MU:mass-unit'.
	b parseAndAddVar: 'MU1:mass-unit'.
	b parseAndAddVar: 'MU2:mass-unit'.
	b parseAndAddRule: 'g Ã· kg â‡’ 1/1000'.
	b parseAndAddRule: 'mg Ã· kg â‡’ 1/1000000'.
	b parseAndAddRule: 'M in MU â‡’ (M Ã· MU) Ã— MU'.
	b parseAndAddRule: 'MU1 Ã· MU2 â‡’ (MU1 Ã· kg) Ã· (MU2 Ã· kg) | Â¬(MU2 == kg)'.
	b build.
]

{ #category : #initialization }
LeibnizExamples >> initialize [
	super initialize.
	self docHash: (SHA256 hashMessage: 'examples') hex.
	self createBooleanContext.
	self createFunctionContext.
	self createDerivativeContext.
	self createMassContext.
	self createMassUnitContext.

]
